<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RBControl: half_duplex_uart.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RBControl
   </div>
   <div id="projectbrief">Library for the RB3201-RBControl board with the ESP32 by RoboticsBrno.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">half_duplex_uart.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;soc/uart_reg.h&quot;</code><br />
<code>#include &quot;soc/uart_struct.h&quot;</code><br />
<code>#include &quot;esp_err.h&quot;</code><br />
<code>#include &quot;esp_intr_alloc.h&quot;</code><br />
<code>#include &quot;driver/periph_ctrl.h&quot;</code><br />
<code>#include &quot;freertos/FreeRTOS.h&quot;</code><br />
<code>#include &quot;freertos/semphr.h&quot;</code><br />
<code>#include &quot;freertos/xtensa_api.h&quot;</code><br />
<code>#include &quot;freertos/task.h&quot;</code><br />
<code>#include &quot;freertos/queue.h&quot;</code><br />
<code>#include &quot;freertos/ringbuf.h&quot;</code><br />
<code>#include &lt;esp_types.h&gt;</code><br />
<code>#include &quot;soc/uart_channel.h&quot;</code><br />
<code>#include &quot;driver/uart.h&quot;</code><br />
</div>
<p><a href="half__duplex__uart_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacerb"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb.html">rb</a></td></tr>
<tr class="memdesc:namespacerb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base namespace. Contains some logging functions, too. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerb_1_1half__duplex"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html">rb::half_duplex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a27d66366ac4fdbde6a6beebe94e2233b"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a27d66366ac4fdbde6a6beebe94e2233b">rb::half_duplex::uart_set_word_length</a> (uart_port_t uart_num, uart_word_length_t data_bit)</td></tr>
<tr class="memdesc:a27d66366ac4fdbde6a6beebe94e2233b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART data bits.  <a href="namespacerb_1_1half__duplex.html#a27d66366ac4fdbde6a6beebe94e2233b">More...</a><br /></td></tr>
<tr class="separator:a27d66366ac4fdbde6a6beebe94e2233b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11271fb53d8681af2be65b569055b6c"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ac11271fb53d8681af2be65b569055b6c">rb::half_duplex::uart_get_word_length</a> (uart_port_t uart_num, uart_word_length_t *data_bit)</td></tr>
<tr class="memdesc:ac11271fb53d8681af2be65b569055b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get UART data bits.  <a href="namespacerb_1_1half__duplex.html#ac11271fb53d8681af2be65b569055b6c">More...</a><br /></td></tr>
<tr class="separator:ac11271fb53d8681af2be65b569055b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a324f4c4610022fc6632f89b90f6ca"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a18a324f4c4610022fc6632f89b90f6ca">rb::half_duplex::uart_set_stop_bits</a> (uart_port_t uart_num, uart_stop_bits_t stop_bits)</td></tr>
<tr class="memdesc:a18a324f4c4610022fc6632f89b90f6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART stop bits.  <a href="namespacerb_1_1half__duplex.html#a18a324f4c4610022fc6632f89b90f6ca">More...</a><br /></td></tr>
<tr class="separator:a18a324f4c4610022fc6632f89b90f6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ec8dda95f28201f3cf7e13a5b7a804"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a95ec8dda95f28201f3cf7e13a5b7a804">rb::half_duplex::uart_get_stop_bits</a> (uart_port_t uart_num, uart_stop_bits_t *stop_bits)</td></tr>
<tr class="memdesc:a95ec8dda95f28201f3cf7e13a5b7a804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get UART stop bits.  <a href="namespacerb_1_1half__duplex.html#a95ec8dda95f28201f3cf7e13a5b7a804">More...</a><br /></td></tr>
<tr class="separator:a95ec8dda95f28201f3cf7e13a5b7a804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc501d08d388094fc40ed62e68f6b214"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#acc501d08d388094fc40ed62e68f6b214">rb::half_duplex::uart_set_parity</a> (uart_port_t uart_num, uart_parity_t parity_mode)</td></tr>
<tr class="memdesc:acc501d08d388094fc40ed62e68f6b214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART parity mode.  <a href="namespacerb_1_1half__duplex.html#acc501d08d388094fc40ed62e68f6b214">More...</a><br /></td></tr>
<tr class="separator:acc501d08d388094fc40ed62e68f6b214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d513be0a9a0d6437e2ad999ba90d67"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ab4d513be0a9a0d6437e2ad999ba90d67">rb::half_duplex::uart_get_parity</a> (uart_port_t uart_num, uart_parity_t *parity_mode)</td></tr>
<tr class="memdesc:ab4d513be0a9a0d6437e2ad999ba90d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get UART parity mode.  <a href="namespacerb_1_1half__duplex.html#ab4d513be0a9a0d6437e2ad999ba90d67">More...</a><br /></td></tr>
<tr class="separator:ab4d513be0a9a0d6437e2ad999ba90d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483c207247e1a4fa6eca681a29e241fe"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a483c207247e1a4fa6eca681a29e241fe">rb::half_duplex::uart_set_baudrate</a> (uart_port_t uart_num, uint32_t baudrate)</td></tr>
<tr class="memdesc:a483c207247e1a4fa6eca681a29e241fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART baud rate.  <a href="namespacerb_1_1half__duplex.html#a483c207247e1a4fa6eca681a29e241fe">More...</a><br /></td></tr>
<tr class="separator:a483c207247e1a4fa6eca681a29e241fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0a1e454f6c4613d31b401cef8af465"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a7e0a1e454f6c4613d31b401cef8af465">rb::half_duplex::uart_get_baudrate</a> (uart_port_t uart_num, uint32_t *baudrate)</td></tr>
<tr class="memdesc:a7e0a1e454f6c4613d31b401cef8af465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get UART baud rate.  <a href="namespacerb_1_1half__duplex.html#a7e0a1e454f6c4613d31b401cef8af465">More...</a><br /></td></tr>
<tr class="separator:a7e0a1e454f6c4613d31b401cef8af465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd6856471b26bbcf3d1063277202e1a"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#aabd6856471b26bbcf3d1063277202e1a">rb::half_duplex::uart_set_line_inverse</a> (uart_port_t uart_num, uint32_t inverse_mask)</td></tr>
<tr class="memdesc:aabd6856471b26bbcf3d1063277202e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART line inverse mode.  <a href="namespacerb_1_1half__duplex.html#aabd6856471b26bbcf3d1063277202e1a">More...</a><br /></td></tr>
<tr class="separator:aabd6856471b26bbcf3d1063277202e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5936f9c5982e58ca02b756aa94ab085c"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a5936f9c5982e58ca02b756aa94ab085c">rb::half_duplex::uart_set_hw_flow_ctrl</a> (uart_port_t uart_num, uart_hw_flowcontrol_t flow_ctrl, uint8_t rx_thresh)</td></tr>
<tr class="memdesc:a5936f9c5982e58ca02b756aa94ab085c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set hardware flow control.  <a href="namespacerb_1_1half__duplex.html#a5936f9c5982e58ca02b756aa94ab085c">More...</a><br /></td></tr>
<tr class="separator:a5936f9c5982e58ca02b756aa94ab085c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca401845d54986ace8201c3944d38ce1"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#aca401845d54986ace8201c3944d38ce1">rb::half_duplex::uart_set_sw_flow_ctrl</a> (uart_port_t uart_num, bool enable, uint8_t rx_thresh_xon, uint8_t rx_thresh_xoff)</td></tr>
<tr class="memdesc:aca401845d54986ace8201c3944d38ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set software flow control.  <a href="namespacerb_1_1half__duplex.html#aca401845d54986ace8201c3944d38ce1">More...</a><br /></td></tr>
<tr class="separator:aca401845d54986ace8201c3944d38ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143ddb73fd0153c732a02652da75ccb6"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a143ddb73fd0153c732a02652da75ccb6">rb::half_duplex::uart_get_hw_flow_ctrl</a> (uart_port_t uart_num, uart_hw_flowcontrol_t *flow_ctrl)</td></tr>
<tr class="memdesc:a143ddb73fd0153c732a02652da75ccb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get hardware flow control mode.  <a href="namespacerb_1_1half__duplex.html#a143ddb73fd0153c732a02652da75ccb6">More...</a><br /></td></tr>
<tr class="separator:a143ddb73fd0153c732a02652da75ccb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54c7f06889b0ed712b2d250957b2b07"><td class="memItemLeft" align="right" valign="top">esp_err_t IRAM_ATTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ad54c7f06889b0ed712b2d250957b2b07">rb::half_duplex::uart_clear_intr_status</a> (uart_port_t uart_num, uint32_t clr_mask)</td></tr>
<tr class="memdesc:ad54c7f06889b0ed712b2d250957b2b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear UART interrupt status.  <a href="namespacerb_1_1half__duplex.html#ad54c7f06889b0ed712b2d250957b2b07">More...</a><br /></td></tr>
<tr class="separator:ad54c7f06889b0ed712b2d250957b2b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5732320d43de532f8ee1370c74458ab5"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a5732320d43de532f8ee1370c74458ab5">rb::half_duplex::uart_enable_intr_mask</a> (uart_port_t uart_num, uint32_t enable_mask)</td></tr>
<tr class="memdesc:a5732320d43de532f8ee1370c74458ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART interrupt enable.  <a href="namespacerb_1_1half__duplex.html#a5732320d43de532f8ee1370c74458ab5">More...</a><br /></td></tr>
<tr class="separator:a5732320d43de532f8ee1370c74458ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d2011f1b0e3f228f1eb4f4f94da4c7"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a85d2011f1b0e3f228f1eb4f4f94da4c7">rb::half_duplex::uart_disable_intr_mask</a> (uart_port_t uart_num, uint32_t disable_mask)</td></tr>
<tr class="memdesc:a85d2011f1b0e3f228f1eb4f4f94da4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear UART interrupt enable bits.  <a href="namespacerb_1_1half__duplex.html#a85d2011f1b0e3f228f1eb4f4f94da4c7">More...</a><br /></td></tr>
<tr class="separator:a85d2011f1b0e3f228f1eb4f4f94da4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e6cf79b6bd21c72e3b525c56e4abf2"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a85e6cf79b6bd21c72e3b525c56e4abf2">rb::half_duplex::uart_enable_rx_intr</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:a85e6cf79b6bd21c72e3b525c56e4abf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable UART RX interrupt (RX_FULL &amp; RX_TIMEOUT INTERRUPT)  <a href="namespacerb_1_1half__duplex.html#a85e6cf79b6bd21c72e3b525c56e4abf2">More...</a><br /></td></tr>
<tr class="separator:a85e6cf79b6bd21c72e3b525c56e4abf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5ceeafeae68d1ccb30e1edbe24618d"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#aba5ceeafeae68d1ccb30e1edbe24618d">rb::half_duplex::uart_disable_rx_intr</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:aba5ceeafeae68d1ccb30e1edbe24618d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable UART RX interrupt (RX_FULL &amp; RX_TIMEOUT INTERRUPT)  <a href="namespacerb_1_1half__duplex.html#aba5ceeafeae68d1ccb30e1edbe24618d">More...</a><br /></td></tr>
<tr class="separator:aba5ceeafeae68d1ccb30e1edbe24618d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df9353751cbf4ee7b2a037454cbcfb1"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a2df9353751cbf4ee7b2a037454cbcfb1">rb::half_duplex::uart_disable_tx_intr</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:a2df9353751cbf4ee7b2a037454cbcfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable UART TX interrupt (TX_FULL &amp; TX_TIMEOUT INTERRUPT)  <a href="namespacerb_1_1half__duplex.html#a2df9353751cbf4ee7b2a037454cbcfb1">More...</a><br /></td></tr>
<tr class="separator:a2df9353751cbf4ee7b2a037454cbcfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3740d2a6ba4eea3ddbc5483c78e9d5"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a6b3740d2a6ba4eea3ddbc5483c78e9d5">rb::half_duplex::uart_enable_tx_intr</a> (uart_port_t uart_num, int enable, int thresh)</td></tr>
<tr class="memdesc:a6b3740d2a6ba4eea3ddbc5483c78e9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable UART TX interrupt (TX_FULL &amp; TX_TIMEOUT INTERRUPT)  <a href="namespacerb_1_1half__duplex.html#a6b3740d2a6ba4eea3ddbc5483c78e9d5">More...</a><br /></td></tr>
<tr class="separator:a6b3740d2a6ba4eea3ddbc5483c78e9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c473d5e0e8583c81a8f5174dfaf6f0"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a27c473d5e0e8583c81a8f5174dfaf6f0">rb::half_duplex::uart_isr_register</a> (uart_port_t uart_num, void(*fn)(void *), void *arg, int intr_alloc_flags, uart_isr_handle_t *handle)</td></tr>
<tr class="memdesc:a27c473d5e0e8583c81a8f5174dfaf6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register UART interrupt handler (ISR).  <a href="namespacerb_1_1half__duplex.html#a27c473d5e0e8583c81a8f5174dfaf6f0">More...</a><br /></td></tr>
<tr class="separator:a27c473d5e0e8583c81a8f5174dfaf6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a9d9440cef6f37a121e2776bca42fb"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#af2a9d9440cef6f37a121e2776bca42fb">rb::half_duplex::uart_isr_free</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:af2a9d9440cef6f37a121e2776bca42fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free UART interrupt handler registered by uart_isr_register. Must be called on the same core as uart_isr_register was called.  <a href="namespacerb_1_1half__duplex.html#af2a9d9440cef6f37a121e2776bca42fb">More...</a><br /></td></tr>
<tr class="separator:af2a9d9440cef6f37a121e2776bca42fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5d171e9b2736dbe54067b292bac9dc"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#adb5d171e9b2736dbe54067b292bac9dc">rb::half_duplex::uart_set_pin</a> (uart_port_t uart_num, int tx_io_num, int rx_io_num, int rts_io_num, int cts_io_num)</td></tr>
<tr class="memdesc:adb5d171e9b2736dbe54067b292bac9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART pin number.  <a href="namespacerb_1_1half__duplex.html#adb5d171e9b2736dbe54067b292bac9dc">More...</a><br /></td></tr>
<tr class="separator:adb5d171e9b2736dbe54067b292bac9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c9b3532a4f3c6e82fb9e0db54bd2b1"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ac9c9b3532a4f3c6e82fb9e0db54bd2b1">rb::half_duplex::uart_set_rts</a> (uart_port_t uart_num, int level)</td></tr>
<tr class="memdesc:ac9c9b3532a4f3c6e82fb9e0db54bd2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually set the UART RTS pin level.  <a href="namespacerb_1_1half__duplex.html#ac9c9b3532a4f3c6e82fb9e0db54bd2b1">More...</a><br /></td></tr>
<tr class="separator:ac9c9b3532a4f3c6e82fb9e0db54bd2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4c34c1609324dd8fd9a123e68fa2ed"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a1a4c34c1609324dd8fd9a123e68fa2ed">rb::half_duplex::uart_set_dtr</a> (uart_port_t uart_num, int level)</td></tr>
<tr class="memdesc:a1a4c34c1609324dd8fd9a123e68fa2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually set the UART DTR pin level.  <a href="namespacerb_1_1half__duplex.html#a1a4c34c1609324dd8fd9a123e68fa2ed">More...</a><br /></td></tr>
<tr class="separator:a1a4c34c1609324dd8fd9a123e68fa2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005ad69a3593c666192633b064a863ce"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a005ad69a3593c666192633b064a863ce">rb::half_duplex::uart_set_tx_idle_num</a> (uart_port_t uart_num, uint16_t idle_num)</td></tr>
<tr class="memdesc:a005ad69a3593c666192633b064a863ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART idle interval after tx FIFO is empty.  <a href="namespacerb_1_1half__duplex.html#a005ad69a3593c666192633b064a863ce">More...</a><br /></td></tr>
<tr class="separator:a005ad69a3593c666192633b064a863ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfbcc5c9205f3e44077603f34b12e95"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#abcfbcc5c9205f3e44077603f34b12e95">rb::half_duplex::uart_param_config</a> (uart_port_t uart_num, const uart_config_t *uart_config)</td></tr>
<tr class="memdesc:abcfbcc5c9205f3e44077603f34b12e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART configuration parameters.  <a href="namespacerb_1_1half__duplex.html#abcfbcc5c9205f3e44077603f34b12e95">More...</a><br /></td></tr>
<tr class="separator:abcfbcc5c9205f3e44077603f34b12e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad676699d64a0764b4b99ac2c5f81a9f4"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ad676699d64a0764b4b99ac2c5f81a9f4">rb::half_duplex::uart_intr_config</a> (uart_port_t uart_num, const uart_intr_config_t *intr_conf)</td></tr>
<tr class="memdesc:ad676699d64a0764b4b99ac2c5f81a9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure UART interrupts.  <a href="namespacerb_1_1half__duplex.html#ad676699d64a0764b4b99ac2c5f81a9f4">More...</a><br /></td></tr>
<tr class="separator:ad676699d64a0764b4b99ac2c5f81a9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6397b0ff1a5965aa9e8a798ba4a785c3"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a6397b0ff1a5965aa9e8a798ba4a785c3">rb::half_duplex::uart_driver_install</a> (uart_port_t uart_num, int rx_buffer_size, int tx_buffer_size, int queue_size, QueueHandle_t *uart_queue, int intr_alloc_flags)</td></tr>
<tr class="memdesc:a6397b0ff1a5965aa9e8a798ba4a785c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install UART driver.  <a href="namespacerb_1_1half__duplex.html#a6397b0ff1a5965aa9e8a798ba4a785c3">More...</a><br /></td></tr>
<tr class="separator:a6397b0ff1a5965aa9e8a798ba4a785c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09968268adff58df7ebc9862d059e7d"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#af09968268adff58df7ebc9862d059e7d">rb::half_duplex::uart_driver_delete</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:af09968268adff58df7ebc9862d059e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninstall UART driver.  <a href="namespacerb_1_1half__duplex.html#af09968268adff58df7ebc9862d059e7d">More...</a><br /></td></tr>
<tr class="separator:af09968268adff58df7ebc9862d059e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4694d911028546a9444ffad0117a9d7b"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a4694d911028546a9444ffad0117a9d7b">rb::half_duplex::uart_wait_tx_done</a> (uart_port_t uart_num, TickType_t ticks_to_wait)</td></tr>
<tr class="memdesc:a4694d911028546a9444ffad0117a9d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until UART TX FIFO is empty.  <a href="namespacerb_1_1half__duplex.html#a4694d911028546a9444ffad0117a9d7b">More...</a><br /></td></tr>
<tr class="separator:a4694d911028546a9444ffad0117a9d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2a4b68f4c6d055da05d9be37b85de4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a2e2a4b68f4c6d055da05d9be37b85de4">rb::half_duplex::uart_tx_chars</a> (uart_port_t uart_num, const char *buffer, uint32_t len)</td></tr>
<tr class="memdesc:a2e2a4b68f4c6d055da05d9be37b85de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to the UART port from a given buffer and length.  <a href="namespacerb_1_1half__duplex.html#a2e2a4b68f4c6d055da05d9be37b85de4">More...</a><br /></td></tr>
<tr class="separator:a2e2a4b68f4c6d055da05d9be37b85de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96caa84729f7fc55f0e5b2837fc9fe3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a96caa84729f7fc55f0e5b2837fc9fe3b">rb::half_duplex::uart_write_bytes</a> (uart_port_t uart_num, const char *src, size_t size)</td></tr>
<tr class="memdesc:a96caa84729f7fc55f0e5b2837fc9fe3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to the UART port from a given buffer and length,.  <a href="namespacerb_1_1half__duplex.html#a96caa84729f7fc55f0e5b2837fc9fe3b">More...</a><br /></td></tr>
<tr class="separator:a96caa84729f7fc55f0e5b2837fc9fe3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cae71bc469939b467af46a5bae8afa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a35cae71bc469939b467af46a5bae8afa">rb::half_duplex::uart_write_bytes_with_break</a> (uart_port_t uart_num, const char *src, size_t size, int brk_len)</td></tr>
<tr class="memdesc:a35cae71bc469939b467af46a5bae8afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to the UART port from a given buffer and length,.  <a href="namespacerb_1_1half__duplex.html#a35cae71bc469939b467af46a5bae8afa">More...</a><br /></td></tr>
<tr class="separator:a35cae71bc469939b467af46a5bae8afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecd33be8298a58b2eede3742a4edab1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#acecd33be8298a58b2eede3742a4edab1">rb::half_duplex::uart_read_bytes</a> (uart_port_t uart_num, uint8_t *buf, uint32_t length, TickType_t ticks_to_wait)</td></tr>
<tr class="memdesc:acecd33be8298a58b2eede3742a4edab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART read bytes from UART buffer.  <a href="namespacerb_1_1half__duplex.html#acecd33be8298a58b2eede3742a4edab1">More...</a><br /></td></tr>
<tr class="separator:acecd33be8298a58b2eede3742a4edab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae84add2edb2b78454c446f0a3a8599"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#acae84add2edb2b78454c446f0a3a8599">rb::half_duplex::uart_flush</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:acae84add2edb2b78454c446f0a3a8599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias of uart_flush_input. UART ring buffer flush. This will discard all data in the UART RX buffer.  <a href="namespacerb_1_1half__duplex.html#acae84add2edb2b78454c446f0a3a8599">More...</a><br /></td></tr>
<tr class="separator:acae84add2edb2b78454c446f0a3a8599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29c3d86b7d3fbb00b5853ff29ba1649"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ad29c3d86b7d3fbb00b5853ff29ba1649">rb::half_duplex::uart_flush_input</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:ad29c3d86b7d3fbb00b5853ff29ba1649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear input buffer, discard all the data is in the ring-buffer.  <a href="namespacerb_1_1half__duplex.html#ad29c3d86b7d3fbb00b5853ff29ba1649">More...</a><br /></td></tr>
<tr class="separator:ad29c3d86b7d3fbb00b5853ff29ba1649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac069f51d37759c69939f5e9a21759dd5"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ac069f51d37759c69939f5e9a21759dd5">rb::half_duplex::uart_get_buffered_data_len</a> (uart_port_t uart_num, size_t *size)</td></tr>
<tr class="memdesc:ac069f51d37759c69939f5e9a21759dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART get RX ring buffer cached data length.  <a href="namespacerb_1_1half__duplex.html#ac069f51d37759c69939f5e9a21759dd5">More...</a><br /></td></tr>
<tr class="separator:ac069f51d37759c69939f5e9a21759dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee5d2eaa41053f6a9d08f318c1f7a92"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a1ee5d2eaa41053f6a9d08f318c1f7a92">rb::half_duplex::uart_disable_pattern_det_intr</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:a1ee5d2eaa41053f6a9d08f318c1f7a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART disable pattern detect function. Designed for applications like 'AT commands'. When the hardware detects a series of one same character, the interrupt will be triggered.  <a href="namespacerb_1_1half__duplex.html#a1ee5d2eaa41053f6a9d08f318c1f7a92">More...</a><br /></td></tr>
<tr class="separator:a1ee5d2eaa41053f6a9d08f318c1f7a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa970a450c5228ab46ca63c93d190d1c9"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#aa970a450c5228ab46ca63c93d190d1c9">rb::half_duplex::uart_enable_pattern_det_intr</a> (uart_port_t uart_num, char pattern_chr, uint8_t chr_num, int chr_tout, int post_idle, int pre_idle)</td></tr>
<tr class="memdesc:aa970a450c5228ab46ca63c93d190d1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART enable pattern detect function. Designed for applications like 'AT commands'. When the hardware detect a series of one same character, the interrupt will be triggered.  <a href="namespacerb_1_1half__duplex.html#aa970a450c5228ab46ca63c93d190d1c9">More...</a><br /></td></tr>
<tr class="separator:aa970a450c5228ab46ca63c93d190d1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f75f37abb2da0ab71a5d75ebea310ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a1f75f37abb2da0ab71a5d75ebea310ff">rb::half_duplex::uart_pattern_pop_pos</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:a1f75f37abb2da0ab71a5d75ebea310ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nearest detected pattern position in buffer. The positions of the detected pattern are saved in a queue, this function will dequeue the first pattern position and move the pointer to next pattern position.  <a href="namespacerb_1_1half__duplex.html#a1f75f37abb2da0ab71a5d75ebea310ff">More...</a><br /></td></tr>
<tr class="separator:a1f75f37abb2da0ab71a5d75ebea310ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dee405ef18d6f6f8847fd8e7420ea0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a3dee405ef18d6f6f8847fd8e7420ea0d">rb::half_duplex::uart_pattern_get_pos</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:a3dee405ef18d6f6f8847fd8e7420ea0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nearest detected pattern position in buffer. The positions of the detected pattern are saved in a queue, This function do nothing to the queue.  <a href="namespacerb_1_1half__duplex.html#a3dee405ef18d6f6f8847fd8e7420ea0d">More...</a><br /></td></tr>
<tr class="separator:a3dee405ef18d6f6f8847fd8e7420ea0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac375694c5957acb53a9f2542bac63ece"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ac375694c5957acb53a9f2542bac63ece">rb::half_duplex::uart_pattern_queue_reset</a> (uart_port_t uart_num, int queue_length)</td></tr>
<tr class="memdesc:ac375694c5957acb53a9f2542bac63ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new memory with the given length to save record the detected pattern position in rx buffer.  <a href="namespacerb_1_1half__duplex.html#ac375694c5957acb53a9f2542bac63ece">More...</a><br /></td></tr>
<tr class="separator:ac375694c5957acb53a9f2542bac63ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51753b8e0db14f66ff7fb88f45cffe82"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a51753b8e0db14f66ff7fb88f45cffe82">rb::half_duplex::uart_set_mode</a> (uart_port_t uart_num, uart_mode_t mode)</td></tr>
<tr class="memdesc:a51753b8e0db14f66ff7fb88f45cffe82"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART set communication mode.  <a href="namespacerb_1_1half__duplex.html#a51753b8e0db14f66ff7fb88f45cffe82">More...</a><br /></td></tr>
<tr class="separator:a51753b8e0db14f66ff7fb88f45cffe82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c96ce90d2dd2a1a3bb3d9b5a455d622"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a0c96ce90d2dd2a1a3bb3d9b5a455d622">rb::half_duplex::uart_set_rx_timeout</a> (uart_port_t uart_num, const uint8_t tout_thresh)</td></tr>
<tr class="memdesc:a0c96ce90d2dd2a1a3bb3d9b5a455d622"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART set threshold timeout for TOUT feature.  <a href="namespacerb_1_1half__duplex.html#a0c96ce90d2dd2a1a3bb3d9b5a455d622">More...</a><br /></td></tr>
<tr class="separator:a0c96ce90d2dd2a1a3bb3d9b5a455d622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ece9765f327a204dca5924ff5539a2b"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a5ece9765f327a204dca5924ff5539a2b">rb::half_duplex::uart_get_collision_flag</a> (uart_port_t uart_num, bool *collision_flag)</td></tr>
<tr class="memdesc:a5ece9765f327a204dca5924ff5539a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns collision detection flag for RS485 mode Function returns the collision detection flag into variable pointed by collision_flag. *collision_flag = true, if collision detected else it is equal to false. This function should be executed when actual transmission is completed (after <a class="el" href="namespacerb_1_1half__duplex.html#a96caa84729f7fc55f0e5b2837fc9fe3b" title="Send data to the UART port from a given buffer and length,. ">uart_write_bytes()</a>).  <a href="namespacerb_1_1half__duplex.html#a5ece9765f327a204dca5924ff5539a2b">More...</a><br /></td></tr>
<tr class="separator:a5ece9765f327a204dca5924ff5539a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac127d35ce7d8746934bf23d62789cfb4"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ac127d35ce7d8746934bf23d62789cfb4">rb::half_duplex::uart_set_wakeup_threshold</a> (uart_port_t uart_num, int wakeup_threshold)</td></tr>
<tr class="memdesc:ac127d35ce7d8746934bf23d62789cfb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of RX pin signal edges for light sleep wakeup.  <a href="namespacerb_1_1half__duplex.html#ac127d35ce7d8746934bf23d62789cfb4">More...</a><br /></td></tr>
<tr class="separator:ac127d35ce7d8746934bf23d62789cfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacbdba371beb96c3ac76e5cc92e979a"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#adacbdba371beb96c3ac76e5cc92e979a">rb::half_duplex::uart_get_wakeup_threshold</a> (uart_port_t uart_num, int *out_wakeup_threshold)</td></tr>
<tr class="memdesc:adacbdba371beb96c3ac76e5cc92e979a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of RX pin signal edges for light sleep wakeup.  <a href="namespacerb_1_1half__duplex.html#adacbdba371beb96c3ac76e5cc92e979a">More...</a><br /></td></tr>
<tr class="separator:adacbdba371beb96c3ac76e5cc92e979a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688539a27d0ed106ce347b79e83a0f3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a688539a27d0ed106ce347b79e83a0f3a">rb::half_duplex::uart_set_half_duplex_pin</a> (uart_port_t uart_num, gpio_num_t pin)</td></tr>
<tr class="separator:a688539a27d0ed106ce347b79e83a0f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Feb 6 2021 13:10:00 for RBControl by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
