<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RBControl: half_duplex_uart.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RBControl
   </div>
   <div id="projectbrief">Library for the RB3201-RBControl board with the ESP32 by RoboticsBrno.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">half_duplex_uart.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;esp_types.h&quot;</code><br />
<code>#include &quot;esp_attr.h&quot;</code><br />
<code>#include &quot;esp_intr_alloc.h&quot;</code><br />
<code>#include &quot;esp_log.h&quot;</code><br />
<code>#include &quot;esp_err.h&quot;</code><br />
<code>#include &quot;esp_clk.h&quot;</code><br />
<code>#include &quot;malloc.h&quot;</code><br />
<code>#include &quot;freertos/FreeRTOS.h&quot;</code><br />
<code>#include &quot;freertos/semphr.h&quot;</code><br />
<code>#include &quot;freertos/xtensa_api.h&quot;</code><br />
<code>#include &quot;freertos/task.h&quot;</code><br />
<code>#include &quot;freertos/ringbuf.h&quot;</code><br />
<code>#include &quot;soc/dport_reg.h&quot;</code><br />
<code>#include &quot;soc/uart_struct.h&quot;</code><br />
<code>#include &quot;driver/uart.h&quot;</code><br />
<code>#include &quot;driver/gpio.h&quot;</code><br />
<code>#include &quot;driver/uart_select.h&quot;</code><br />
<code>#include &quot;<a class="el" href="half__duplex__uart_8h_source.html">half_duplex_uart.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrb_1_1half__duplex_1_1uart__tx__data__t.html">rb::half_duplex::uart_tx_data_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrb_1_1half__duplex_1_1uart__pat__rb__t.html">rb::half_duplex::uart_pat_rb_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrb_1_1half__duplex_1_1uart__obj__t.html">rb::half_duplex::uart_obj_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacerb"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb.html">rb</a></td></tr>
<tr class="memdesc:namespacerb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base namespace. Contains some logging functions, too. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerb_1_1half__duplex"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html">rb::half_duplex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a67fd78ae15d2b67c10d44d69a49ab1c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="half__duplex__uart_8cpp.html#a67fd78ae15d2b67c10d44d69a49ab1c5">XOFF</a>&#160;&#160;&#160;(char)0x13</td></tr>
<tr class="separator:a67fd78ae15d2b67c10d44d69a49ab1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf721774c51e08c6609e6fa8cf82cc9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="half__duplex__uart_8cpp.html#acdf721774c51e08c6609e6fa8cf82cc9">XON</a>&#160;&#160;&#160;(char)0x11</td></tr>
<tr class="separator:acdf721774c51e08c6609e6fa8cf82cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3419b73d1a2cf57c49db6d893a506da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="half__duplex__uart_8cpp.html#ab3419b73d1a2cf57c49db6d893a506da">UART_CHECK</a>(a,  str,  ret_val)</td></tr>
<tr class="separator:ab3419b73d1a2cf57c49db6d893a506da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c8d990e6b23b1b3057c99a31df1234"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="half__duplex__uart_8cpp.html#ae2c8d990e6b23b1b3057c99a31df1234">UART_EMPTY_THRESH_DEFAULT</a>&#160;&#160;&#160;(10)</td></tr>
<tr class="separator:ae2c8d990e6b23b1b3057c99a31df1234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae970e80c5ea5e136de03e0ca2eb3b051"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="half__duplex__uart_8cpp.html#ae970e80c5ea5e136de03e0ca2eb3b051">UART_FULL_THRESH_DEFAULT</a>&#160;&#160;&#160;(120)</td></tr>
<tr class="separator:ae970e80c5ea5e136de03e0ca2eb3b051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dee42ec29c8731cbc98c222041cc0f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="half__duplex__uart_8cpp.html#a25dee42ec29c8731cbc98c222041cc0f">UART_TOUT_THRESH_DEFAULT</a>&#160;&#160;&#160;(10)</td></tr>
<tr class="separator:a25dee42ec29c8731cbc98c222041cc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4ad73ed9fa6c15b7f70762539f60da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="half__duplex__uart_8cpp.html#a7e4ad73ed9fa6c15b7f70762539f60da">UART_CLKDIV_FRAG_BIT_WIDTH</a>&#160;&#160;&#160;(3)</td></tr>
<tr class="separator:a7e4ad73ed9fa6c15b7f70762539f60da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04813d9639c58a48d03d9a1a814b798"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="half__duplex__uart_8cpp.html#ac04813d9639c58a48d03d9a1a814b798">UART_TOUT_REF_FACTOR_DEFAULT</a>&#160;&#160;&#160;(UART_CLK_FREQ/(REF_CLK_FREQ&lt;&lt;<a class="el" href="half__duplex__uart_8cpp.html#a7e4ad73ed9fa6c15b7f70762539f60da">UART_CLKDIV_FRAG_BIT_WIDTH</a>))</td></tr>
<tr class="separator:ac04813d9639c58a48d03d9a1a814b798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b61f0884a7144c196a67327e67e3032"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="half__duplex__uart_8cpp.html#a9b61f0884a7144c196a67327e67e3032">UART_TX_IDLE_NUM_DEFAULT</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:a9b61f0884a7144c196a67327e67e3032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b7e3380aa3772b5dc7d143eb63aa53"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="half__duplex__uart_8cpp.html#a42b7e3380aa3772b5dc7d143eb63aa53">UART_PATTERN_DET_QLEN_DEFAULT</a>&#160;&#160;&#160;(10)</td></tr>
<tr class="separator:a42b7e3380aa3772b5dc7d143eb63aa53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60af713b131a91dec4b443445d49152"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="half__duplex__uart_8cpp.html#ab60af713b131a91dec4b443445d49152">UART_MIN_WAKEUP_THRESH</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="separator:ab60af713b131a91dec4b443445d49152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3f9d9a8733108f351078d1e21c8350"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="half__duplex__uart_8cpp.html#a9c3f9d9a8733108f351078d1e21c8350">UART_ENTER_CRITICAL_ISR</a>(mux)&#160;&#160;&#160;portENTER_CRITICAL_ISR(mux)</td></tr>
<tr class="separator:a9c3f9d9a8733108f351078d1e21c8350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5758754a4616d5ea434dad32306547b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="half__duplex__uart_8cpp.html#a5758754a4616d5ea434dad32306547b3">UART_EXIT_CRITICAL_ISR</a>(mux)&#160;&#160;&#160;portEXIT_CRITICAL_ISR(mux)</td></tr>
<tr class="separator:a5758754a4616d5ea434dad32306547b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85b7fe73bf9feb6193a0b9b7c5ee9b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="half__duplex__uart_8cpp.html#ae85b7fe73bf9feb6193a0b9b7c5ee9b7">UART_ENTER_CRITICAL</a>(mux)&#160;&#160;&#160;portENTER_CRITICAL(mux)</td></tr>
<tr class="separator:ae85b7fe73bf9feb6193a0b9b7c5ee9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea1d3cb364ffa40c9ff6757067ec220"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="half__duplex__uart_8cpp.html#a7ea1d3cb364ffa40c9ff6757067ec220">UART_EXIT_CRITICAL</a>(mux)&#160;&#160;&#160;portEXIT_CRITICAL(mux)</td></tr>
<tr class="separator:a7ea1d3cb364ffa40c9ff6757067ec220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fdaab92702703c09244697eed7f77b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="half__duplex__uart_8cpp.html#ac2fdaab92702703c09244697eed7f77b">UART_IS_MODE_SET</a>(uart_number,  mode)&#160;&#160;&#160;((p_uart_obj[uart_number]-&gt;uart_mode == mode))</td></tr>
<tr class="separator:ac2fdaab92702703c09244697eed7f77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a27d66366ac4fdbde6a6beebe94e2233b"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a27d66366ac4fdbde6a6beebe94e2233b">rb::half_duplex::uart_set_word_length</a> (uart_port_t uart_num, uart_word_length_t data_bit)</td></tr>
<tr class="memdesc:a27d66366ac4fdbde6a6beebe94e2233b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART data bits.  <a href="namespacerb_1_1half__duplex.html#a27d66366ac4fdbde6a6beebe94e2233b">More...</a><br /></td></tr>
<tr class="separator:a27d66366ac4fdbde6a6beebe94e2233b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11271fb53d8681af2be65b569055b6c"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ac11271fb53d8681af2be65b569055b6c">rb::half_duplex::uart_get_word_length</a> (uart_port_t uart_num, uart_word_length_t *data_bit)</td></tr>
<tr class="memdesc:ac11271fb53d8681af2be65b569055b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get UART data bits.  <a href="namespacerb_1_1half__duplex.html#ac11271fb53d8681af2be65b569055b6c">More...</a><br /></td></tr>
<tr class="separator:ac11271fb53d8681af2be65b569055b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a324f4c4610022fc6632f89b90f6ca"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a18a324f4c4610022fc6632f89b90f6ca">rb::half_duplex::uart_set_stop_bits</a> (uart_port_t uart_num, uart_stop_bits_t stop_bits)</td></tr>
<tr class="memdesc:a18a324f4c4610022fc6632f89b90f6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART stop bits.  <a href="namespacerb_1_1half__duplex.html#a18a324f4c4610022fc6632f89b90f6ca">More...</a><br /></td></tr>
<tr class="separator:a18a324f4c4610022fc6632f89b90f6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ec8dda95f28201f3cf7e13a5b7a804"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a95ec8dda95f28201f3cf7e13a5b7a804">rb::half_duplex::uart_get_stop_bits</a> (uart_port_t uart_num, uart_stop_bits_t *stop_bits)</td></tr>
<tr class="memdesc:a95ec8dda95f28201f3cf7e13a5b7a804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get UART stop bits.  <a href="namespacerb_1_1half__duplex.html#a95ec8dda95f28201f3cf7e13a5b7a804">More...</a><br /></td></tr>
<tr class="separator:a95ec8dda95f28201f3cf7e13a5b7a804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc501d08d388094fc40ed62e68f6b214"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#acc501d08d388094fc40ed62e68f6b214">rb::half_duplex::uart_set_parity</a> (uart_port_t uart_num, uart_parity_t parity_mode)</td></tr>
<tr class="memdesc:acc501d08d388094fc40ed62e68f6b214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART parity mode.  <a href="namespacerb_1_1half__duplex.html#acc501d08d388094fc40ed62e68f6b214">More...</a><br /></td></tr>
<tr class="separator:acc501d08d388094fc40ed62e68f6b214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d513be0a9a0d6437e2ad999ba90d67"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ab4d513be0a9a0d6437e2ad999ba90d67">rb::half_duplex::uart_get_parity</a> (uart_port_t uart_num, uart_parity_t *parity_mode)</td></tr>
<tr class="memdesc:ab4d513be0a9a0d6437e2ad999ba90d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get UART parity mode.  <a href="namespacerb_1_1half__duplex.html#ab4d513be0a9a0d6437e2ad999ba90d67">More...</a><br /></td></tr>
<tr class="separator:ab4d513be0a9a0d6437e2ad999ba90d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483c207247e1a4fa6eca681a29e241fe"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a483c207247e1a4fa6eca681a29e241fe">rb::half_duplex::uart_set_baudrate</a> (uart_port_t uart_num, uint32_t baudrate)</td></tr>
<tr class="memdesc:a483c207247e1a4fa6eca681a29e241fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART baud rate.  <a href="namespacerb_1_1half__duplex.html#a483c207247e1a4fa6eca681a29e241fe">More...</a><br /></td></tr>
<tr class="separator:a483c207247e1a4fa6eca681a29e241fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0a1e454f6c4613d31b401cef8af465"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a7e0a1e454f6c4613d31b401cef8af465">rb::half_duplex::uart_get_baudrate</a> (uart_port_t uart_num, uint32_t *baudrate)</td></tr>
<tr class="memdesc:a7e0a1e454f6c4613d31b401cef8af465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get UART baud rate.  <a href="namespacerb_1_1half__duplex.html#a7e0a1e454f6c4613d31b401cef8af465">More...</a><br /></td></tr>
<tr class="separator:a7e0a1e454f6c4613d31b401cef8af465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd6856471b26bbcf3d1063277202e1a"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#aabd6856471b26bbcf3d1063277202e1a">rb::half_duplex::uart_set_line_inverse</a> (uart_port_t uart_num, uint32_t inverse_mask)</td></tr>
<tr class="memdesc:aabd6856471b26bbcf3d1063277202e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART line inverse mode.  <a href="namespacerb_1_1half__duplex.html#aabd6856471b26bbcf3d1063277202e1a">More...</a><br /></td></tr>
<tr class="separator:aabd6856471b26bbcf3d1063277202e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca401845d54986ace8201c3944d38ce1"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#aca401845d54986ace8201c3944d38ce1">rb::half_duplex::uart_set_sw_flow_ctrl</a> (uart_port_t uart_num, bool enable, uint8_t rx_thresh_xon, uint8_t rx_thresh_xoff)</td></tr>
<tr class="memdesc:aca401845d54986ace8201c3944d38ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set software flow control.  <a href="namespacerb_1_1half__duplex.html#aca401845d54986ace8201c3944d38ce1">More...</a><br /></td></tr>
<tr class="separator:aca401845d54986ace8201c3944d38ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5936f9c5982e58ca02b756aa94ab085c"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a5936f9c5982e58ca02b756aa94ab085c">rb::half_duplex::uart_set_hw_flow_ctrl</a> (uart_port_t uart_num, uart_hw_flowcontrol_t flow_ctrl, uint8_t rx_thresh)</td></tr>
<tr class="memdesc:a5936f9c5982e58ca02b756aa94ab085c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set hardware flow control.  <a href="namespacerb_1_1half__duplex.html#a5936f9c5982e58ca02b756aa94ab085c">More...</a><br /></td></tr>
<tr class="separator:a5936f9c5982e58ca02b756aa94ab085c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143ddb73fd0153c732a02652da75ccb6"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a143ddb73fd0153c732a02652da75ccb6">rb::half_duplex::uart_get_hw_flow_ctrl</a> (uart_port_t uart_num, uart_hw_flowcontrol_t *flow_ctrl)</td></tr>
<tr class="memdesc:a143ddb73fd0153c732a02652da75ccb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get hardware flow control mode.  <a href="namespacerb_1_1half__duplex.html#a143ddb73fd0153c732a02652da75ccb6">More...</a><br /></td></tr>
<tr class="separator:a143ddb73fd0153c732a02652da75ccb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd3bf348fb8ea9292a279ae2a683f40"><td class="memItemLeft" align="right" valign="top">static esp_err_t IRAM_ATTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a0dd3bf348fb8ea9292a279ae2a683f40">rb::half_duplex::uart_reset_rx_fifo</a> (uart_port_t uart_num)</td></tr>
<tr class="separator:a0dd3bf348fb8ea9292a279ae2a683f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54c7f06889b0ed712b2d250957b2b07"><td class="memItemLeft" align="right" valign="top">esp_err_t IRAM_ATTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ad54c7f06889b0ed712b2d250957b2b07">rb::half_duplex::uart_clear_intr_status</a> (uart_port_t uart_num, uint32_t clr_mask)</td></tr>
<tr class="memdesc:ad54c7f06889b0ed712b2d250957b2b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear UART interrupt status.  <a href="namespacerb_1_1half__duplex.html#ad54c7f06889b0ed712b2d250957b2b07">More...</a><br /></td></tr>
<tr class="separator:ad54c7f06889b0ed712b2d250957b2b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5732320d43de532f8ee1370c74458ab5"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a5732320d43de532f8ee1370c74458ab5">rb::half_duplex::uart_enable_intr_mask</a> (uart_port_t uart_num, uint32_t enable_mask)</td></tr>
<tr class="memdesc:a5732320d43de532f8ee1370c74458ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART interrupt enable.  <a href="namespacerb_1_1half__duplex.html#a5732320d43de532f8ee1370c74458ab5">More...</a><br /></td></tr>
<tr class="separator:a5732320d43de532f8ee1370c74458ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d2011f1b0e3f228f1eb4f4f94da4c7"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a85d2011f1b0e3f228f1eb4f4f94da4c7">rb::half_duplex::uart_disable_intr_mask</a> (uart_port_t uart_num, uint32_t disable_mask)</td></tr>
<tr class="memdesc:a85d2011f1b0e3f228f1eb4f4f94da4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear UART interrupt enable bits.  <a href="namespacerb_1_1half__duplex.html#a85d2011f1b0e3f228f1eb4f4f94da4c7">More...</a><br /></td></tr>
<tr class="separator:a85d2011f1b0e3f228f1eb4f4f94da4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e359e6bcc880298e49735dac146104"><td class="memItemLeft" align="right" valign="top">static void IRAM_ATTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ad7e359e6bcc880298e49735dac146104">rb::half_duplex::uart_disable_intr_mask_from_isr</a> (uart_port_t uart_num, uint32_t disable_mask)</td></tr>
<tr class="separator:ad7e359e6bcc880298e49735dac146104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f769909082c6230487ee9de5e46e946"><td class="memItemLeft" align="right" valign="top">static void IRAM_ATTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a9f769909082c6230487ee9de5e46e946">rb::half_duplex::uart_enable_intr_mask_from_isr</a> (uart_port_t uart_num, uint32_t enable_mask)</td></tr>
<tr class="separator:a9f769909082c6230487ee9de5e46e946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03d83caf0ba3c404b9e5ce82b1b1e94"><td class="memItemLeft" align="right" valign="top">static esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ad03d83caf0ba3c404b9e5ce82b1b1e94">rb::half_duplex::uart_pattern_link_free</a> (uart_port_t uart_num)</td></tr>
<tr class="separator:ad03d83caf0ba3c404b9e5ce82b1b1e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c5e29896368c1fd8841b880694a4a5"><td class="memItemLeft" align="right" valign="top">static esp_err_t IRAM_ATTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ab3c5e29896368c1fd8841b880694a4a5">rb::half_duplex::uart_pattern_enqueue</a> (uart_port_t uart_num, int pos)</td></tr>
<tr class="separator:ab3c5e29896368c1fd8841b880694a4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5918c60ee771ed97264834ac0e357f1d"><td class="memItemLeft" align="right" valign="top">static esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a5918c60ee771ed97264834ac0e357f1d">rb::half_duplex::uart_pattern_dequeue</a> (uart_port_t uart_num)</td></tr>
<tr class="separator:a5918c60ee771ed97264834ac0e357f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44c67ca8076af494ec4ed8a15709b26"><td class="memItemLeft" align="right" valign="top">static esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ab44c67ca8076af494ec4ed8a15709b26">rb::half_duplex::uart_pattern_queue_update</a> (uart_port_t uart_num, int diff_len)</td></tr>
<tr class="separator:ab44c67ca8076af494ec4ed8a15709b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f75f37abb2da0ab71a5d75ebea310ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a1f75f37abb2da0ab71a5d75ebea310ff">rb::half_duplex::uart_pattern_pop_pos</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:a1f75f37abb2da0ab71a5d75ebea310ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nearest detected pattern position in buffer. The positions of the detected pattern are saved in a queue, this function will dequeue the first pattern position and move the pointer to next pattern position.  <a href="namespacerb_1_1half__duplex.html#a1f75f37abb2da0ab71a5d75ebea310ff">More...</a><br /></td></tr>
<tr class="separator:a1f75f37abb2da0ab71a5d75ebea310ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dee405ef18d6f6f8847fd8e7420ea0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a3dee405ef18d6f6f8847fd8e7420ea0d">rb::half_duplex::uart_pattern_get_pos</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:a3dee405ef18d6f6f8847fd8e7420ea0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nearest detected pattern position in buffer. The positions of the detected pattern are saved in a queue, This function do nothing to the queue.  <a href="namespacerb_1_1half__duplex.html#a3dee405ef18d6f6f8847fd8e7420ea0d">More...</a><br /></td></tr>
<tr class="separator:a3dee405ef18d6f6f8847fd8e7420ea0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac375694c5957acb53a9f2542bac63ece"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ac375694c5957acb53a9f2542bac63ece">rb::half_duplex::uart_pattern_queue_reset</a> (uart_port_t uart_num, int queue_length)</td></tr>
<tr class="memdesc:ac375694c5957acb53a9f2542bac63ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new memory with the given length to save record the detected pattern position in rx buffer.  <a href="namespacerb_1_1half__duplex.html#ac375694c5957acb53a9f2542bac63ece">More...</a><br /></td></tr>
<tr class="separator:ac375694c5957acb53a9f2542bac63ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa970a450c5228ab46ca63c93d190d1c9"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#aa970a450c5228ab46ca63c93d190d1c9">rb::half_duplex::uart_enable_pattern_det_intr</a> (uart_port_t uart_num, char pattern_chr, uint8_t chr_num, int chr_tout, int post_idle, int pre_idle)</td></tr>
<tr class="memdesc:aa970a450c5228ab46ca63c93d190d1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART enable pattern detect function. Designed for applications like 'AT commands'. When the hardware detect a series of one same character, the interrupt will be triggered.  <a href="namespacerb_1_1half__duplex.html#aa970a450c5228ab46ca63c93d190d1c9">More...</a><br /></td></tr>
<tr class="separator:aa970a450c5228ab46ca63c93d190d1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee5d2eaa41053f6a9d08f318c1f7a92"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a1ee5d2eaa41053f6a9d08f318c1f7a92">rb::half_duplex::uart_disable_pattern_det_intr</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:a1ee5d2eaa41053f6a9d08f318c1f7a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART disable pattern detect function. Designed for applications like 'AT commands'. When the hardware detects a series of one same character, the interrupt will be triggered.  <a href="namespacerb_1_1half__duplex.html#a1ee5d2eaa41053f6a9d08f318c1f7a92">More...</a><br /></td></tr>
<tr class="separator:a1ee5d2eaa41053f6a9d08f318c1f7a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e6cf79b6bd21c72e3b525c56e4abf2"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a85e6cf79b6bd21c72e3b525c56e4abf2">rb::half_duplex::uart_enable_rx_intr</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:a85e6cf79b6bd21c72e3b525c56e4abf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable UART RX interrupt (RX_FULL &amp; RX_TIMEOUT INTERRUPT)  <a href="namespacerb_1_1half__duplex.html#a85e6cf79b6bd21c72e3b525c56e4abf2">More...</a><br /></td></tr>
<tr class="separator:a85e6cf79b6bd21c72e3b525c56e4abf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5ceeafeae68d1ccb30e1edbe24618d"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#aba5ceeafeae68d1ccb30e1edbe24618d">rb::half_duplex::uart_disable_rx_intr</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:aba5ceeafeae68d1ccb30e1edbe24618d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable UART RX interrupt (RX_FULL &amp; RX_TIMEOUT INTERRUPT)  <a href="namespacerb_1_1half__duplex.html#aba5ceeafeae68d1ccb30e1edbe24618d">More...</a><br /></td></tr>
<tr class="separator:aba5ceeafeae68d1ccb30e1edbe24618d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df9353751cbf4ee7b2a037454cbcfb1"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a2df9353751cbf4ee7b2a037454cbcfb1">rb::half_duplex::uart_disable_tx_intr</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:a2df9353751cbf4ee7b2a037454cbcfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable UART TX interrupt (TX_FULL &amp; TX_TIMEOUT INTERRUPT)  <a href="namespacerb_1_1half__duplex.html#a2df9353751cbf4ee7b2a037454cbcfb1">More...</a><br /></td></tr>
<tr class="separator:a2df9353751cbf4ee7b2a037454cbcfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3740d2a6ba4eea3ddbc5483c78e9d5"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a6b3740d2a6ba4eea3ddbc5483c78e9d5">rb::half_duplex::uart_enable_tx_intr</a> (uart_port_t uart_num, int enable, int thresh)</td></tr>
<tr class="memdesc:a6b3740d2a6ba4eea3ddbc5483c78e9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable UART TX interrupt (TX_FULL &amp; TX_TIMEOUT INTERRUPT)  <a href="namespacerb_1_1half__duplex.html#a6b3740d2a6ba4eea3ddbc5483c78e9d5">More...</a><br /></td></tr>
<tr class="separator:a6b3740d2a6ba4eea3ddbc5483c78e9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c473d5e0e8583c81a8f5174dfaf6f0"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a27c473d5e0e8583c81a8f5174dfaf6f0">rb::half_duplex::uart_isr_register</a> (uart_port_t uart_num, void(*fn)(void *), void *arg, int intr_alloc_flags, uart_isr_handle_t *handle)</td></tr>
<tr class="memdesc:a27c473d5e0e8583c81a8f5174dfaf6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register UART interrupt handler (ISR).  <a href="namespacerb_1_1half__duplex.html#a27c473d5e0e8583c81a8f5174dfaf6f0">More...</a><br /></td></tr>
<tr class="separator:a27c473d5e0e8583c81a8f5174dfaf6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a9d9440cef6f37a121e2776bca42fb"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#af2a9d9440cef6f37a121e2776bca42fb">rb::half_duplex::uart_isr_free</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:af2a9d9440cef6f37a121e2776bca42fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free UART interrupt handler registered by uart_isr_register. Must be called on the same core as uart_isr_register was called.  <a href="namespacerb_1_1half__duplex.html#af2a9d9440cef6f37a121e2776bca42fb">More...</a><br /></td></tr>
<tr class="separator:af2a9d9440cef6f37a121e2776bca42fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5d171e9b2736dbe54067b292bac9dc"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#adb5d171e9b2736dbe54067b292bac9dc">rb::half_duplex::uart_set_pin</a> (uart_port_t uart_num, int tx_io_num, int rx_io_num, int rts_io_num, int cts_io_num)</td></tr>
<tr class="memdesc:adb5d171e9b2736dbe54067b292bac9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART pin number.  <a href="namespacerb_1_1half__duplex.html#adb5d171e9b2736dbe54067b292bac9dc">More...</a><br /></td></tr>
<tr class="separator:adb5d171e9b2736dbe54067b292bac9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c9b3532a4f3c6e82fb9e0db54bd2b1"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ac9c9b3532a4f3c6e82fb9e0db54bd2b1">rb::half_duplex::uart_set_rts</a> (uart_port_t uart_num, int level)</td></tr>
<tr class="memdesc:ac9c9b3532a4f3c6e82fb9e0db54bd2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually set the UART RTS pin level.  <a href="namespacerb_1_1half__duplex.html#ac9c9b3532a4f3c6e82fb9e0db54bd2b1">More...</a><br /></td></tr>
<tr class="separator:ac9c9b3532a4f3c6e82fb9e0db54bd2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4c34c1609324dd8fd9a123e68fa2ed"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a1a4c34c1609324dd8fd9a123e68fa2ed">rb::half_duplex::uart_set_dtr</a> (uart_port_t uart_num, int level)</td></tr>
<tr class="memdesc:a1a4c34c1609324dd8fd9a123e68fa2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually set the UART DTR pin level.  <a href="namespacerb_1_1half__duplex.html#a1a4c34c1609324dd8fd9a123e68fa2ed">More...</a><br /></td></tr>
<tr class="separator:a1a4c34c1609324dd8fd9a123e68fa2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005ad69a3593c666192633b064a863ce"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a005ad69a3593c666192633b064a863ce">rb::half_duplex::uart_set_tx_idle_num</a> (uart_port_t uart_num, uint16_t idle_num)</td></tr>
<tr class="memdesc:a005ad69a3593c666192633b064a863ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART idle interval after tx FIFO is empty.  <a href="namespacerb_1_1half__duplex.html#a005ad69a3593c666192633b064a863ce">More...</a><br /></td></tr>
<tr class="separator:a005ad69a3593c666192633b064a863ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfbcc5c9205f3e44077603f34b12e95"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#abcfbcc5c9205f3e44077603f34b12e95">rb::half_duplex::uart_param_config</a> (uart_port_t uart_num, const uart_config_t *uart_config)</td></tr>
<tr class="memdesc:abcfbcc5c9205f3e44077603f34b12e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART configuration parameters.  <a href="namespacerb_1_1half__duplex.html#abcfbcc5c9205f3e44077603f34b12e95">More...</a><br /></td></tr>
<tr class="separator:abcfbcc5c9205f3e44077603f34b12e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad676699d64a0764b4b99ac2c5f81a9f4"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ad676699d64a0764b4b99ac2c5f81a9f4">rb::half_duplex::uart_intr_config</a> (uart_port_t uart_num, const uart_intr_config_t *intr_conf)</td></tr>
<tr class="memdesc:ad676699d64a0764b4b99ac2c5f81a9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure UART interrupts.  <a href="namespacerb_1_1half__duplex.html#ad676699d64a0764b4b99ac2c5f81a9f4">More...</a><br /></td></tr>
<tr class="separator:ad676699d64a0764b4b99ac2c5f81a9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfffb16b07365324bf1a80f1f650b0f8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#adfffb16b07365324bf1a80f1f650b0f8">rb::half_duplex::uart_find_pattern_from_last</a> (uint8_t *buf, int length, uint8_t pat_chr, int pat_num)</td></tr>
<tr class="separator:adfffb16b07365324bf1a80f1f650b0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0151a08b86a592f95aa38a3f39d842ad"><td class="memItemLeft" align="right" valign="top">static void IRAM_ATTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a0151a08b86a592f95aa38a3f39d842ad">rb::half_duplex::uart_rx_intr_handler_default</a> (void *param)</td></tr>
<tr class="separator:a0151a08b86a592f95aa38a3f39d842ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdc54423692e437e725175d508ce79b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a6cdc54423692e437e725175d508ce79b">rb::half_duplex::uart_fill_fifo</a> (uart_port_t uart_num, const char *buffer, uint32_t len)</td></tr>
<tr class="separator:a6cdc54423692e437e725175d508ce79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2a4b68f4c6d055da05d9be37b85de4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a2e2a4b68f4c6d055da05d9be37b85de4">rb::half_duplex::uart_tx_chars</a> (uart_port_t uart_num, const char *buffer, uint32_t len)</td></tr>
<tr class="memdesc:a2e2a4b68f4c6d055da05d9be37b85de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to the UART port from a given buffer and length.  <a href="namespacerb_1_1half__duplex.html#a2e2a4b68f4c6d055da05d9be37b85de4">More...</a><br /></td></tr>
<tr class="separator:a2e2a4b68f4c6d055da05d9be37b85de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836834577a08951e806331f0616420e9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a836834577a08951e806331f0616420e9">rb::half_duplex::uart_check_buf_full</a> (uart_port_t uart_num)</td></tr>
<tr class="separator:a836834577a08951e806331f0616420e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecd33be8298a58b2eede3742a4edab1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#acecd33be8298a58b2eede3742a4edab1">rb::half_duplex::uart_read_bytes</a> (uart_port_t uart_num, uint8_t *buf, uint32_t length, TickType_t ticks_to_wait)</td></tr>
<tr class="memdesc:acecd33be8298a58b2eede3742a4edab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART read bytes from UART buffer.  <a href="namespacerb_1_1half__duplex.html#acecd33be8298a58b2eede3742a4edab1">More...</a><br /></td></tr>
<tr class="separator:acecd33be8298a58b2eede3742a4edab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac069f51d37759c69939f5e9a21759dd5"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ac069f51d37759c69939f5e9a21759dd5">rb::half_duplex::uart_get_buffered_data_len</a> (uart_port_t uart_num, size_t *size)</td></tr>
<tr class="memdesc:ac069f51d37759c69939f5e9a21759dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART get RX ring buffer cached data length.  <a href="namespacerb_1_1half__duplex.html#ac069f51d37759c69939f5e9a21759dd5">More...</a><br /></td></tr>
<tr class="separator:ac069f51d37759c69939f5e9a21759dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29c3d86b7d3fbb00b5853ff29ba1649"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ad29c3d86b7d3fbb00b5853ff29ba1649">rb::half_duplex::uart_flush_input</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:ad29c3d86b7d3fbb00b5853ff29ba1649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear input buffer, discard all the data is in the ring-buffer.  <a href="namespacerb_1_1half__duplex.html#ad29c3d86b7d3fbb00b5853ff29ba1649">More...</a><br /></td></tr>
<tr class="separator:ad29c3d86b7d3fbb00b5853ff29ba1649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae84add2edb2b78454c446f0a3a8599"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#acae84add2edb2b78454c446f0a3a8599">rb::half_duplex::uart_flush</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:acae84add2edb2b78454c446f0a3a8599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias of uart_flush_input. UART ring buffer flush. This will discard all data in the UART RX buffer.  <a href="namespacerb_1_1half__duplex.html#acae84add2edb2b78454c446f0a3a8599">More...</a><br /></td></tr>
<tr class="separator:acae84add2edb2b78454c446f0a3a8599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6397b0ff1a5965aa9e8a798ba4a785c3"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a6397b0ff1a5965aa9e8a798ba4a785c3">rb::half_duplex::uart_driver_install</a> (uart_port_t uart_num, int rx_buffer_size, int tx_buffer_size, int queue_size, QueueHandle_t *uart_queue, int intr_alloc_flags)</td></tr>
<tr class="memdesc:a6397b0ff1a5965aa9e8a798ba4a785c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install UART driver.  <a href="namespacerb_1_1half__duplex.html#a6397b0ff1a5965aa9e8a798ba4a785c3">More...</a><br /></td></tr>
<tr class="separator:a6397b0ff1a5965aa9e8a798ba4a785c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09968268adff58df7ebc9862d059e7d"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#af09968268adff58df7ebc9862d059e7d">rb::half_duplex::uart_driver_delete</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:af09968268adff58df7ebc9862d059e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninstall UART driver.  <a href="namespacerb_1_1half__duplex.html#af09968268adff58df7ebc9862d059e7d">More...</a><br /></td></tr>
<tr class="separator:af09968268adff58df7ebc9862d059e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02508deed3506a2f99cbc6cb502d5181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a02508deed3506a2f99cbc6cb502d5181">rb::half_duplex::uart_set_select_notif_callback</a> (uart_port_t uart_num, uart_select_notif_callback_t uart_select_notif_callback)</td></tr>
<tr class="separator:a02508deed3506a2f99cbc6cb502d5181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6060066f0f3f6b9846d5bb0389e0ffb"><td class="memItemLeft" align="right" valign="top">portMUX_TYPE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ac6060066f0f3f6b9846d5bb0389e0ffb">rb::half_duplex::uart_get_selectlock</a> ()</td></tr>
<tr class="separator:ac6060066f0f3f6b9846d5bb0389e0ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51753b8e0db14f66ff7fb88f45cffe82"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a51753b8e0db14f66ff7fb88f45cffe82">rb::half_duplex::uart_set_mode</a> (uart_port_t uart_num, uart_mode_t mode)</td></tr>
<tr class="memdesc:a51753b8e0db14f66ff7fb88f45cffe82"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART set communication mode.  <a href="namespacerb_1_1half__duplex.html#a51753b8e0db14f66ff7fb88f45cffe82">More...</a><br /></td></tr>
<tr class="separator:a51753b8e0db14f66ff7fb88f45cffe82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c96ce90d2dd2a1a3bb3d9b5a455d622"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a0c96ce90d2dd2a1a3bb3d9b5a455d622">rb::half_duplex::uart_set_rx_timeout</a> (uart_port_t uart_num, const uint8_t tout_thresh)</td></tr>
<tr class="memdesc:a0c96ce90d2dd2a1a3bb3d9b5a455d622"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART set threshold timeout for TOUT feature.  <a href="namespacerb_1_1half__duplex.html#a0c96ce90d2dd2a1a3bb3d9b5a455d622">More...</a><br /></td></tr>
<tr class="separator:a0c96ce90d2dd2a1a3bb3d9b5a455d622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ece9765f327a204dca5924ff5539a2b"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a5ece9765f327a204dca5924ff5539a2b">rb::half_duplex::uart_get_collision_flag</a> (uart_port_t uart_num, bool *collision_flag)</td></tr>
<tr class="memdesc:a5ece9765f327a204dca5924ff5539a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns collision detection flag for RS485 mode Function returns the collision detection flag into variable pointed by collision_flag. *collision_flag = true, if collision detected else it is equal to false. This function should be executed when actual transmission is completed (after <a class="el" href="namespacerb_1_1half__duplex.html#a96caa84729f7fc55f0e5b2837fc9fe3b" title="Send data to the UART port from a given buffer and length,.">uart_write_bytes()</a>).  <a href="namespacerb_1_1half__duplex.html#a5ece9765f327a204dca5924ff5539a2b">More...</a><br /></td></tr>
<tr class="separator:a5ece9765f327a204dca5924ff5539a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac127d35ce7d8746934bf23d62789cfb4"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ac127d35ce7d8746934bf23d62789cfb4">rb::half_duplex::uart_set_wakeup_threshold</a> (uart_port_t uart_num, int wakeup_threshold)</td></tr>
<tr class="memdesc:ac127d35ce7d8746934bf23d62789cfb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of RX pin signal edges for light sleep wakeup.  <a href="namespacerb_1_1half__duplex.html#ac127d35ce7d8746934bf23d62789cfb4">More...</a><br /></td></tr>
<tr class="separator:ac127d35ce7d8746934bf23d62789cfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacbdba371beb96c3ac76e5cc92e979a"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#adacbdba371beb96c3ac76e5cc92e979a">rb::half_duplex::uart_get_wakeup_threshold</a> (uart_port_t uart_num, int *out_wakeup_threshold)</td></tr>
<tr class="memdesc:adacbdba371beb96c3ac76e5cc92e979a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of RX pin signal edges for light sleep wakeup.  <a href="namespacerb_1_1half__duplex.html#adacbdba371beb96c3ac76e5cc92e979a">More...</a><br /></td></tr>
<tr class="separator:adacbdba371beb96c3ac76e5cc92e979a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688539a27d0ed106ce347b79e83a0f3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a688539a27d0ed106ce347b79e83a0f3a">rb::half_duplex::uart_set_half_duplex_pin</a> (uart_port_t uart_num, gpio_num_t pin)</td></tr>
<tr class="separator:a688539a27d0ed106ce347b79e83a0f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aad486903eae2719ad55a0ef2f9994af8"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#aad486903eae2719ad55a0ef2f9994af8">rb::half_duplex::UART_TAG</a> = &quot;uart&quot;</td></tr>
<tr class="separator:aad486903eae2719ad55a0ef2f9994af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75df6ede6007a82332d41a0fd81b2d6"><td class="memItemLeft" align="right" valign="top">static uart_obj_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#af75df6ede6007a82332d41a0fd81b2d6">rb::half_duplex::p_uart_obj</a> [UART_NUM_MAX] = {0}</td></tr>
<tr class="separator:af75df6ede6007a82332d41a0fd81b2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e7511b0933aeb278d56d201d523447"><td class="memItemLeft" align="right" valign="top">static DRAM_ATTR uart_dev_t *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a61e7511b0933aeb278d56d201d523447">rb::half_duplex::UART</a> [UART_NUM_MAX] = {&amp;UART0, &amp;UART1, &amp;UART2}</td></tr>
<tr class="separator:a61e7511b0933aeb278d56d201d523447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac883fcf84a8983483aca4be1d9f5dbf4"><td class="memItemLeft" align="right" valign="top">static portMUX_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ac883fcf84a8983483aca4be1d9f5dbf4">rb::half_duplex::uart_spinlock</a> [UART_NUM_MAX] = {portMUX_INITIALIZER_UNLOCKED, portMUX_INITIALIZER_UNLOCKED, portMUX_INITIALIZER_UNLOCKED}</td></tr>
<tr class="separator:ac883fcf84a8983483aca4be1d9f5dbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abc4fc64bb528b110aca21749f6de6e"><td class="memItemLeft" align="right" valign="top">static portMUX_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a3abc4fc64bb528b110aca21749f6de6e">rb::half_duplex::uart_selectlock</a> = portMUX_INITIALIZER_UNLOCKED</td></tr>
<tr class="separator:a3abc4fc64bb528b110aca21749f6de6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ab3419b73d1a2cf57c49db6d893a506da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3419b73d1a2cf57c49db6d893a506da">&#9670;&nbsp;</a></span>UART_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_CHECK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">str, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ret_val&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">if</span> (!(a)) { \</div>
<div class="line">        ESP_LOGE(<a class="code" href="namespacerb_1_1half__duplex.html#aad486903eae2719ad55a0ef2f9994af8">UART_TAG</a>,<span class="stringliteral">&quot;%s(%d): %s&quot;</span>, __FUNCTION__, __LINE__, str); \</div>
<div class="line">        return (ret_val); \</div>
<div class="line">    }</div>
<div class="ttc" id="anamespacerb_1_1half__duplex_html_aad486903eae2719ad55a0ef2f9994af8"><div class="ttname"><a href="namespacerb_1_1half__duplex.html#aad486903eae2719ad55a0ef2f9994af8">rb::half_duplex::UART_TAG</a></div><div class="ttdeci">static const char * UART_TAG</div><div class="ttdef"><b>Definition:</b> half_duplex_uart.cpp:59</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7e4ad73ed9fa6c15b7f70762539f60da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4ad73ed9fa6c15b7f70762539f60da">&#9670;&nbsp;</a></span>UART_CLKDIV_FRAG_BIT_WIDTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_CLKDIV_FRAG_BIT_WIDTH&#160;&#160;&#160;(3)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2c8d990e6b23b1b3057c99a31df1234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c8d990e6b23b1b3057c99a31df1234">&#9670;&nbsp;</a></span>UART_EMPTY_THRESH_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_EMPTY_THRESH_DEFAULT&#160;&#160;&#160;(10)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae85b7fe73bf9feb6193a0b9b7c5ee9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85b7fe73bf9feb6193a0b9b7c5ee9b7">&#9670;&nbsp;</a></span>UART_ENTER_CRITICAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_ENTER_CRITICAL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mux</td><td>)</td>
          <td>&#160;&#160;&#160;portENTER_CRITICAL(mux)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c3f9d9a8733108f351078d1e21c8350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3f9d9a8733108f351078d1e21c8350">&#9670;&nbsp;</a></span>UART_ENTER_CRITICAL_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_ENTER_CRITICAL_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mux</td><td>)</td>
          <td>&#160;&#160;&#160;portENTER_CRITICAL_ISR(mux)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ea1d3cb364ffa40c9ff6757067ec220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea1d3cb364ffa40c9ff6757067ec220">&#9670;&nbsp;</a></span>UART_EXIT_CRITICAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_EXIT_CRITICAL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mux</td><td>)</td>
          <td>&#160;&#160;&#160;portEXIT_CRITICAL(mux)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5758754a4616d5ea434dad32306547b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5758754a4616d5ea434dad32306547b3">&#9670;&nbsp;</a></span>UART_EXIT_CRITICAL_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_EXIT_CRITICAL_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mux</td><td>)</td>
          <td>&#160;&#160;&#160;portEXIT_CRITICAL_ISR(mux)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae970e80c5ea5e136de03e0ca2eb3b051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae970e80c5ea5e136de03e0ca2eb3b051">&#9670;&nbsp;</a></span>UART_FULL_THRESH_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_FULL_THRESH_DEFAULT&#160;&#160;&#160;(120)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2fdaab92702703c09244697eed7f77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fdaab92702703c09244697eed7f77b">&#9670;&nbsp;</a></span>UART_IS_MODE_SET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_IS_MODE_SET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">uart_number, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mode&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((p_uart_obj[uart_number]-&gt;uart_mode == mode))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab60af713b131a91dec4b443445d49152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab60af713b131a91dec4b443445d49152">&#9670;&nbsp;</a></span>UART_MIN_WAKEUP_THRESH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_MIN_WAKEUP_THRESH&#160;&#160;&#160;(2)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42b7e3380aa3772b5dc7d143eb63aa53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b7e3380aa3772b5dc7d143eb63aa53">&#9670;&nbsp;</a></span>UART_PATTERN_DET_QLEN_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_PATTERN_DET_QLEN_DEFAULT&#160;&#160;&#160;(10)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac04813d9639c58a48d03d9a1a814b798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04813d9639c58a48d03d9a1a814b798">&#9670;&nbsp;</a></span>UART_TOUT_REF_FACTOR_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_TOUT_REF_FACTOR_DEFAULT&#160;&#160;&#160;(UART_CLK_FREQ/(REF_CLK_FREQ&lt;&lt;<a class="el" href="half__duplex__uart_8cpp.html#a7e4ad73ed9fa6c15b7f70762539f60da">UART_CLKDIV_FRAG_BIT_WIDTH</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a25dee42ec29c8731cbc98c222041cc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25dee42ec29c8731cbc98c222041cc0f">&#9670;&nbsp;</a></span>UART_TOUT_THRESH_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_TOUT_THRESH_DEFAULT&#160;&#160;&#160;(10)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b61f0884a7144c196a67327e67e3032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b61f0884a7144c196a67327e67e3032">&#9670;&nbsp;</a></span>UART_TX_IDLE_NUM_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_TX_IDLE_NUM_DEFAULT&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67fd78ae15d2b67c10d44d69a49ab1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67fd78ae15d2b67c10d44d69a49ab1c5">&#9670;&nbsp;</a></span>XOFF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XOFF&#160;&#160;&#160;(char)0x13</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acdf721774c51e08c6609e6fa8cf82cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf721774c51e08c6609e6fa8cf82cc9">&#9670;&nbsp;</a></span>XON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XON&#160;&#160;&#160;(char)0x11</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Feb 6 2021 13:33:57 for RBControl by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
