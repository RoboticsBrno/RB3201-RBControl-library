<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RBControl: rb::half_duplex Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RBControl
   </div>
   <div id="projectbrief">Library for the RB3201-RBControl board with the ESP32 by RoboticsBrno.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerb.html">rb</a></li><li class="navelem"><a class="el" href="namespacerb_1_1half__duplex.html">half_duplex</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">rb::half_duplex Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrb_1_1half__duplex_1_1uart__obj__t.html">uart_obj_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrb_1_1half__duplex_1_1uart__pat__rb__t.html">uart_pat_rb_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrb_1_1half__duplex_1_1uart__tx__data__t.html">uart_tx_data_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a27d66366ac4fdbde6a6beebe94e2233b"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a27d66366ac4fdbde6a6beebe94e2233b">uart_set_word_length</a> (uart_port_t uart_num, uart_word_length_t data_bit)</td></tr>
<tr class="memdesc:a27d66366ac4fdbde6a6beebe94e2233b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART data bits.  <a href="#a27d66366ac4fdbde6a6beebe94e2233b">More...</a><br /></td></tr>
<tr class="separator:a27d66366ac4fdbde6a6beebe94e2233b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11271fb53d8681af2be65b569055b6c"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ac11271fb53d8681af2be65b569055b6c">uart_get_word_length</a> (uart_port_t uart_num, uart_word_length_t *data_bit)</td></tr>
<tr class="memdesc:ac11271fb53d8681af2be65b569055b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get UART data bits.  <a href="#ac11271fb53d8681af2be65b569055b6c">More...</a><br /></td></tr>
<tr class="separator:ac11271fb53d8681af2be65b569055b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a324f4c4610022fc6632f89b90f6ca"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a18a324f4c4610022fc6632f89b90f6ca">uart_set_stop_bits</a> (uart_port_t uart_num, uart_stop_bits_t stop_bits)</td></tr>
<tr class="memdesc:a18a324f4c4610022fc6632f89b90f6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART stop bits.  <a href="#a18a324f4c4610022fc6632f89b90f6ca">More...</a><br /></td></tr>
<tr class="separator:a18a324f4c4610022fc6632f89b90f6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ec8dda95f28201f3cf7e13a5b7a804"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a95ec8dda95f28201f3cf7e13a5b7a804">uart_get_stop_bits</a> (uart_port_t uart_num, uart_stop_bits_t *stop_bits)</td></tr>
<tr class="memdesc:a95ec8dda95f28201f3cf7e13a5b7a804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get UART stop bits.  <a href="#a95ec8dda95f28201f3cf7e13a5b7a804">More...</a><br /></td></tr>
<tr class="separator:a95ec8dda95f28201f3cf7e13a5b7a804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc501d08d388094fc40ed62e68f6b214"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#acc501d08d388094fc40ed62e68f6b214">uart_set_parity</a> (uart_port_t uart_num, uart_parity_t parity_mode)</td></tr>
<tr class="memdesc:acc501d08d388094fc40ed62e68f6b214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART parity mode.  <a href="#acc501d08d388094fc40ed62e68f6b214">More...</a><br /></td></tr>
<tr class="separator:acc501d08d388094fc40ed62e68f6b214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d513be0a9a0d6437e2ad999ba90d67"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ab4d513be0a9a0d6437e2ad999ba90d67">uart_get_parity</a> (uart_port_t uart_num, uart_parity_t *parity_mode)</td></tr>
<tr class="memdesc:ab4d513be0a9a0d6437e2ad999ba90d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get UART parity mode.  <a href="#ab4d513be0a9a0d6437e2ad999ba90d67">More...</a><br /></td></tr>
<tr class="separator:ab4d513be0a9a0d6437e2ad999ba90d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483c207247e1a4fa6eca681a29e241fe"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a483c207247e1a4fa6eca681a29e241fe">uart_set_baudrate</a> (uart_port_t uart_num, uint32_t baudrate)</td></tr>
<tr class="memdesc:a483c207247e1a4fa6eca681a29e241fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART baud rate.  <a href="#a483c207247e1a4fa6eca681a29e241fe">More...</a><br /></td></tr>
<tr class="separator:a483c207247e1a4fa6eca681a29e241fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0a1e454f6c4613d31b401cef8af465"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a7e0a1e454f6c4613d31b401cef8af465">uart_get_baudrate</a> (uart_port_t uart_num, uint32_t *baudrate)</td></tr>
<tr class="memdesc:a7e0a1e454f6c4613d31b401cef8af465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get UART baud rate.  <a href="#a7e0a1e454f6c4613d31b401cef8af465">More...</a><br /></td></tr>
<tr class="separator:a7e0a1e454f6c4613d31b401cef8af465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd6856471b26bbcf3d1063277202e1a"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#aabd6856471b26bbcf3d1063277202e1a">uart_set_line_inverse</a> (uart_port_t uart_num, uint32_t inverse_mask)</td></tr>
<tr class="memdesc:aabd6856471b26bbcf3d1063277202e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART line inverse mode.  <a href="#aabd6856471b26bbcf3d1063277202e1a">More...</a><br /></td></tr>
<tr class="separator:aabd6856471b26bbcf3d1063277202e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca401845d54986ace8201c3944d38ce1"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#aca401845d54986ace8201c3944d38ce1">uart_set_sw_flow_ctrl</a> (uart_port_t uart_num, bool enable, uint8_t rx_thresh_xon, uint8_t rx_thresh_xoff)</td></tr>
<tr class="memdesc:aca401845d54986ace8201c3944d38ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set software flow control.  <a href="#aca401845d54986ace8201c3944d38ce1">More...</a><br /></td></tr>
<tr class="separator:aca401845d54986ace8201c3944d38ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5936f9c5982e58ca02b756aa94ab085c"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a5936f9c5982e58ca02b756aa94ab085c">uart_set_hw_flow_ctrl</a> (uart_port_t uart_num, uart_hw_flowcontrol_t flow_ctrl, uint8_t rx_thresh)</td></tr>
<tr class="memdesc:a5936f9c5982e58ca02b756aa94ab085c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set hardware flow control.  <a href="#a5936f9c5982e58ca02b756aa94ab085c">More...</a><br /></td></tr>
<tr class="separator:a5936f9c5982e58ca02b756aa94ab085c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143ddb73fd0153c732a02652da75ccb6"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a143ddb73fd0153c732a02652da75ccb6">uart_get_hw_flow_ctrl</a> (uart_port_t uart_num, uart_hw_flowcontrol_t *flow_ctrl)</td></tr>
<tr class="memdesc:a143ddb73fd0153c732a02652da75ccb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get hardware flow control mode.  <a href="#a143ddb73fd0153c732a02652da75ccb6">More...</a><br /></td></tr>
<tr class="separator:a143ddb73fd0153c732a02652da75ccb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd3bf348fb8ea9292a279ae2a683f40"><td class="memItemLeft" align="right" valign="top">static esp_err_t IRAM_ATTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a0dd3bf348fb8ea9292a279ae2a683f40">uart_reset_rx_fifo</a> (uart_port_t uart_num)</td></tr>
<tr class="separator:a0dd3bf348fb8ea9292a279ae2a683f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54c7f06889b0ed712b2d250957b2b07"><td class="memItemLeft" align="right" valign="top">esp_err_t IRAM_ATTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ad54c7f06889b0ed712b2d250957b2b07">uart_clear_intr_status</a> (uart_port_t uart_num, uint32_t clr_mask)</td></tr>
<tr class="memdesc:ad54c7f06889b0ed712b2d250957b2b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear UART interrupt status.  <a href="#ad54c7f06889b0ed712b2d250957b2b07">More...</a><br /></td></tr>
<tr class="separator:ad54c7f06889b0ed712b2d250957b2b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5732320d43de532f8ee1370c74458ab5"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a5732320d43de532f8ee1370c74458ab5">uart_enable_intr_mask</a> (uart_port_t uart_num, uint32_t enable_mask)</td></tr>
<tr class="memdesc:a5732320d43de532f8ee1370c74458ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART interrupt enable.  <a href="#a5732320d43de532f8ee1370c74458ab5">More...</a><br /></td></tr>
<tr class="separator:a5732320d43de532f8ee1370c74458ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d2011f1b0e3f228f1eb4f4f94da4c7"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a85d2011f1b0e3f228f1eb4f4f94da4c7">uart_disable_intr_mask</a> (uart_port_t uart_num, uint32_t disable_mask)</td></tr>
<tr class="memdesc:a85d2011f1b0e3f228f1eb4f4f94da4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear UART interrupt enable bits.  <a href="#a85d2011f1b0e3f228f1eb4f4f94da4c7">More...</a><br /></td></tr>
<tr class="separator:a85d2011f1b0e3f228f1eb4f4f94da4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e359e6bcc880298e49735dac146104"><td class="memItemLeft" align="right" valign="top">static void IRAM_ATTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ad7e359e6bcc880298e49735dac146104">uart_disable_intr_mask_from_isr</a> (uart_port_t uart_num, uint32_t disable_mask)</td></tr>
<tr class="separator:ad7e359e6bcc880298e49735dac146104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f769909082c6230487ee9de5e46e946"><td class="memItemLeft" align="right" valign="top">static void IRAM_ATTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a9f769909082c6230487ee9de5e46e946">uart_enable_intr_mask_from_isr</a> (uart_port_t uart_num, uint32_t enable_mask)</td></tr>
<tr class="separator:a9f769909082c6230487ee9de5e46e946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03d83caf0ba3c404b9e5ce82b1b1e94"><td class="memItemLeft" align="right" valign="top">static esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ad03d83caf0ba3c404b9e5ce82b1b1e94">uart_pattern_link_free</a> (uart_port_t uart_num)</td></tr>
<tr class="separator:ad03d83caf0ba3c404b9e5ce82b1b1e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c5e29896368c1fd8841b880694a4a5"><td class="memItemLeft" align="right" valign="top">static esp_err_t IRAM_ATTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ab3c5e29896368c1fd8841b880694a4a5">uart_pattern_enqueue</a> (uart_port_t uart_num, int pos)</td></tr>
<tr class="separator:ab3c5e29896368c1fd8841b880694a4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5918c60ee771ed97264834ac0e357f1d"><td class="memItemLeft" align="right" valign="top">static esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a5918c60ee771ed97264834ac0e357f1d">uart_pattern_dequeue</a> (uart_port_t uart_num)</td></tr>
<tr class="separator:a5918c60ee771ed97264834ac0e357f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44c67ca8076af494ec4ed8a15709b26"><td class="memItemLeft" align="right" valign="top">static esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ab44c67ca8076af494ec4ed8a15709b26">uart_pattern_queue_update</a> (uart_port_t uart_num, int diff_len)</td></tr>
<tr class="separator:ab44c67ca8076af494ec4ed8a15709b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f75f37abb2da0ab71a5d75ebea310ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a1f75f37abb2da0ab71a5d75ebea310ff">uart_pattern_pop_pos</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:a1f75f37abb2da0ab71a5d75ebea310ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nearest detected pattern position in buffer. The positions of the detected pattern are saved in a queue, this function will dequeue the first pattern position and move the pointer to next pattern position.  <a href="#a1f75f37abb2da0ab71a5d75ebea310ff">More...</a><br /></td></tr>
<tr class="separator:a1f75f37abb2da0ab71a5d75ebea310ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dee405ef18d6f6f8847fd8e7420ea0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a3dee405ef18d6f6f8847fd8e7420ea0d">uart_pattern_get_pos</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:a3dee405ef18d6f6f8847fd8e7420ea0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nearest detected pattern position in buffer. The positions of the detected pattern are saved in a queue, This function do nothing to the queue.  <a href="#a3dee405ef18d6f6f8847fd8e7420ea0d">More...</a><br /></td></tr>
<tr class="separator:a3dee405ef18d6f6f8847fd8e7420ea0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac375694c5957acb53a9f2542bac63ece"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ac375694c5957acb53a9f2542bac63ece">uart_pattern_queue_reset</a> (uart_port_t uart_num, int queue_length)</td></tr>
<tr class="memdesc:ac375694c5957acb53a9f2542bac63ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new memory with the given length to save record the detected pattern position in rx buffer.  <a href="#ac375694c5957acb53a9f2542bac63ece">More...</a><br /></td></tr>
<tr class="separator:ac375694c5957acb53a9f2542bac63ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa970a450c5228ab46ca63c93d190d1c9"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#aa970a450c5228ab46ca63c93d190d1c9">uart_enable_pattern_det_intr</a> (uart_port_t uart_num, char pattern_chr, uint8_t chr_num, int chr_tout, int post_idle, int pre_idle)</td></tr>
<tr class="memdesc:aa970a450c5228ab46ca63c93d190d1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART enable pattern detect function. Designed for applications like 'AT commands'. When the hardware detect a series of one same character, the interrupt will be triggered.  <a href="#aa970a450c5228ab46ca63c93d190d1c9">More...</a><br /></td></tr>
<tr class="separator:aa970a450c5228ab46ca63c93d190d1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee5d2eaa41053f6a9d08f318c1f7a92"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a1ee5d2eaa41053f6a9d08f318c1f7a92">uart_disable_pattern_det_intr</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:a1ee5d2eaa41053f6a9d08f318c1f7a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART disable pattern detect function. Designed for applications like 'AT commands'. When the hardware detects a series of one same character, the interrupt will be triggered.  <a href="#a1ee5d2eaa41053f6a9d08f318c1f7a92">More...</a><br /></td></tr>
<tr class="separator:a1ee5d2eaa41053f6a9d08f318c1f7a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e6cf79b6bd21c72e3b525c56e4abf2"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a85e6cf79b6bd21c72e3b525c56e4abf2">uart_enable_rx_intr</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:a85e6cf79b6bd21c72e3b525c56e4abf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable UART RX interrupt (RX_FULL &amp; RX_TIMEOUT INTERRUPT)  <a href="#a85e6cf79b6bd21c72e3b525c56e4abf2">More...</a><br /></td></tr>
<tr class="separator:a85e6cf79b6bd21c72e3b525c56e4abf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5ceeafeae68d1ccb30e1edbe24618d"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#aba5ceeafeae68d1ccb30e1edbe24618d">uart_disable_rx_intr</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:aba5ceeafeae68d1ccb30e1edbe24618d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable UART RX interrupt (RX_FULL &amp; RX_TIMEOUT INTERRUPT)  <a href="#aba5ceeafeae68d1ccb30e1edbe24618d">More...</a><br /></td></tr>
<tr class="separator:aba5ceeafeae68d1ccb30e1edbe24618d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df9353751cbf4ee7b2a037454cbcfb1"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a2df9353751cbf4ee7b2a037454cbcfb1">uart_disable_tx_intr</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:a2df9353751cbf4ee7b2a037454cbcfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable UART TX interrupt (TX_FULL &amp; TX_TIMEOUT INTERRUPT)  <a href="#a2df9353751cbf4ee7b2a037454cbcfb1">More...</a><br /></td></tr>
<tr class="separator:a2df9353751cbf4ee7b2a037454cbcfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3740d2a6ba4eea3ddbc5483c78e9d5"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a6b3740d2a6ba4eea3ddbc5483c78e9d5">uart_enable_tx_intr</a> (uart_port_t uart_num, int enable, int thresh)</td></tr>
<tr class="memdesc:a6b3740d2a6ba4eea3ddbc5483c78e9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable UART TX interrupt (TX_FULL &amp; TX_TIMEOUT INTERRUPT)  <a href="#a6b3740d2a6ba4eea3ddbc5483c78e9d5">More...</a><br /></td></tr>
<tr class="separator:a6b3740d2a6ba4eea3ddbc5483c78e9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c473d5e0e8583c81a8f5174dfaf6f0"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a27c473d5e0e8583c81a8f5174dfaf6f0">uart_isr_register</a> (uart_port_t uart_num, void(*fn)(void *), void *arg, int intr_alloc_flags, uart_isr_handle_t *handle)</td></tr>
<tr class="memdesc:a27c473d5e0e8583c81a8f5174dfaf6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register UART interrupt handler (ISR).  <a href="#a27c473d5e0e8583c81a8f5174dfaf6f0">More...</a><br /></td></tr>
<tr class="separator:a27c473d5e0e8583c81a8f5174dfaf6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a9d9440cef6f37a121e2776bca42fb"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#af2a9d9440cef6f37a121e2776bca42fb">uart_isr_free</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:af2a9d9440cef6f37a121e2776bca42fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free UART interrupt handler registered by uart_isr_register. Must be called on the same core as uart_isr_register was called.  <a href="#af2a9d9440cef6f37a121e2776bca42fb">More...</a><br /></td></tr>
<tr class="separator:af2a9d9440cef6f37a121e2776bca42fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5d171e9b2736dbe54067b292bac9dc"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#adb5d171e9b2736dbe54067b292bac9dc">uart_set_pin</a> (uart_port_t uart_num, int tx_io_num, int rx_io_num, int rts_io_num, int cts_io_num)</td></tr>
<tr class="memdesc:adb5d171e9b2736dbe54067b292bac9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART pin number.  <a href="#adb5d171e9b2736dbe54067b292bac9dc">More...</a><br /></td></tr>
<tr class="separator:adb5d171e9b2736dbe54067b292bac9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c9b3532a4f3c6e82fb9e0db54bd2b1"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ac9c9b3532a4f3c6e82fb9e0db54bd2b1">uart_set_rts</a> (uart_port_t uart_num, int level)</td></tr>
<tr class="memdesc:ac9c9b3532a4f3c6e82fb9e0db54bd2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually set the UART RTS pin level.  <a href="#ac9c9b3532a4f3c6e82fb9e0db54bd2b1">More...</a><br /></td></tr>
<tr class="separator:ac9c9b3532a4f3c6e82fb9e0db54bd2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4c34c1609324dd8fd9a123e68fa2ed"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a1a4c34c1609324dd8fd9a123e68fa2ed">uart_set_dtr</a> (uart_port_t uart_num, int level)</td></tr>
<tr class="memdesc:a1a4c34c1609324dd8fd9a123e68fa2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually set the UART DTR pin level.  <a href="#a1a4c34c1609324dd8fd9a123e68fa2ed">More...</a><br /></td></tr>
<tr class="separator:a1a4c34c1609324dd8fd9a123e68fa2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005ad69a3593c666192633b064a863ce"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a005ad69a3593c666192633b064a863ce">uart_set_tx_idle_num</a> (uart_port_t uart_num, uint16_t idle_num)</td></tr>
<tr class="memdesc:a005ad69a3593c666192633b064a863ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART idle interval after tx FIFO is empty.  <a href="#a005ad69a3593c666192633b064a863ce">More...</a><br /></td></tr>
<tr class="separator:a005ad69a3593c666192633b064a863ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfbcc5c9205f3e44077603f34b12e95"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#abcfbcc5c9205f3e44077603f34b12e95">uart_param_config</a> (uart_port_t uart_num, const uart_config_t *uart_config)</td></tr>
<tr class="memdesc:abcfbcc5c9205f3e44077603f34b12e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART configuration parameters.  <a href="#abcfbcc5c9205f3e44077603f34b12e95">More...</a><br /></td></tr>
<tr class="separator:abcfbcc5c9205f3e44077603f34b12e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad676699d64a0764b4b99ac2c5f81a9f4"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ad676699d64a0764b4b99ac2c5f81a9f4">uart_intr_config</a> (uart_port_t uart_num, const uart_intr_config_t *intr_conf)</td></tr>
<tr class="memdesc:ad676699d64a0764b4b99ac2c5f81a9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure UART interrupts.  <a href="#ad676699d64a0764b4b99ac2c5f81a9f4">More...</a><br /></td></tr>
<tr class="separator:ad676699d64a0764b4b99ac2c5f81a9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfffb16b07365324bf1a80f1f650b0f8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#adfffb16b07365324bf1a80f1f650b0f8">uart_find_pattern_from_last</a> (uint8_t *buf, int length, uint8_t pat_chr, int pat_num)</td></tr>
<tr class="separator:adfffb16b07365324bf1a80f1f650b0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0151a08b86a592f95aa38a3f39d842ad"><td class="memItemLeft" align="right" valign="top">static void IRAM_ATTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a0151a08b86a592f95aa38a3f39d842ad">uart_rx_intr_handler_default</a> (void *param)</td></tr>
<tr class="separator:a0151a08b86a592f95aa38a3f39d842ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdc54423692e437e725175d508ce79b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a6cdc54423692e437e725175d508ce79b">uart_fill_fifo</a> (uart_port_t uart_num, const char *buffer, uint32_t len)</td></tr>
<tr class="separator:a6cdc54423692e437e725175d508ce79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2a4b68f4c6d055da05d9be37b85de4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a2e2a4b68f4c6d055da05d9be37b85de4">uart_tx_chars</a> (uart_port_t uart_num, const char *buffer, uint32_t len)</td></tr>
<tr class="memdesc:a2e2a4b68f4c6d055da05d9be37b85de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to the UART port from a given buffer and length.  <a href="#a2e2a4b68f4c6d055da05d9be37b85de4">More...</a><br /></td></tr>
<tr class="separator:a2e2a4b68f4c6d055da05d9be37b85de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836834577a08951e806331f0616420e9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a836834577a08951e806331f0616420e9">uart_check_buf_full</a> (uart_port_t uart_num)</td></tr>
<tr class="separator:a836834577a08951e806331f0616420e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecd33be8298a58b2eede3742a4edab1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#acecd33be8298a58b2eede3742a4edab1">uart_read_bytes</a> (uart_port_t uart_num, uint8_t *buf, uint32_t length, TickType_t ticks_to_wait)</td></tr>
<tr class="memdesc:acecd33be8298a58b2eede3742a4edab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART read bytes from UART buffer.  <a href="#acecd33be8298a58b2eede3742a4edab1">More...</a><br /></td></tr>
<tr class="separator:acecd33be8298a58b2eede3742a4edab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac069f51d37759c69939f5e9a21759dd5"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ac069f51d37759c69939f5e9a21759dd5">uart_get_buffered_data_len</a> (uart_port_t uart_num, size_t *size)</td></tr>
<tr class="memdesc:ac069f51d37759c69939f5e9a21759dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART get RX ring buffer cached data length.  <a href="#ac069f51d37759c69939f5e9a21759dd5">More...</a><br /></td></tr>
<tr class="separator:ac069f51d37759c69939f5e9a21759dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29c3d86b7d3fbb00b5853ff29ba1649"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ad29c3d86b7d3fbb00b5853ff29ba1649">uart_flush_input</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:ad29c3d86b7d3fbb00b5853ff29ba1649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear input buffer, discard all the data is in the ring-buffer.  <a href="#ad29c3d86b7d3fbb00b5853ff29ba1649">More...</a><br /></td></tr>
<tr class="separator:ad29c3d86b7d3fbb00b5853ff29ba1649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae84add2edb2b78454c446f0a3a8599"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#acae84add2edb2b78454c446f0a3a8599">uart_flush</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:acae84add2edb2b78454c446f0a3a8599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias of uart_flush_input. UART ring buffer flush. This will discard all data in the UART RX buffer.  <a href="#acae84add2edb2b78454c446f0a3a8599">More...</a><br /></td></tr>
<tr class="separator:acae84add2edb2b78454c446f0a3a8599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6397b0ff1a5965aa9e8a798ba4a785c3"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a6397b0ff1a5965aa9e8a798ba4a785c3">uart_driver_install</a> (uart_port_t uart_num, int rx_buffer_size, int tx_buffer_size, int queue_size, QueueHandle_t *uart_queue, int intr_alloc_flags)</td></tr>
<tr class="memdesc:a6397b0ff1a5965aa9e8a798ba4a785c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install UART driver.  <a href="#a6397b0ff1a5965aa9e8a798ba4a785c3">More...</a><br /></td></tr>
<tr class="separator:a6397b0ff1a5965aa9e8a798ba4a785c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09968268adff58df7ebc9862d059e7d"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#af09968268adff58df7ebc9862d059e7d">uart_driver_delete</a> (uart_port_t uart_num)</td></tr>
<tr class="memdesc:af09968268adff58df7ebc9862d059e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninstall UART driver.  <a href="#af09968268adff58df7ebc9862d059e7d">More...</a><br /></td></tr>
<tr class="separator:af09968268adff58df7ebc9862d059e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02508deed3506a2f99cbc6cb502d5181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a02508deed3506a2f99cbc6cb502d5181">uart_set_select_notif_callback</a> (uart_port_t uart_num, uart_select_notif_callback_t uart_select_notif_callback)</td></tr>
<tr class="separator:a02508deed3506a2f99cbc6cb502d5181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6060066f0f3f6b9846d5bb0389e0ffb"><td class="memItemLeft" align="right" valign="top">portMUX_TYPE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ac6060066f0f3f6b9846d5bb0389e0ffb">uart_get_selectlock</a> ()</td></tr>
<tr class="separator:ac6060066f0f3f6b9846d5bb0389e0ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51753b8e0db14f66ff7fb88f45cffe82"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a51753b8e0db14f66ff7fb88f45cffe82">uart_set_mode</a> (uart_port_t uart_num, uart_mode_t mode)</td></tr>
<tr class="memdesc:a51753b8e0db14f66ff7fb88f45cffe82"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART set communication mode.  <a href="#a51753b8e0db14f66ff7fb88f45cffe82">More...</a><br /></td></tr>
<tr class="separator:a51753b8e0db14f66ff7fb88f45cffe82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c96ce90d2dd2a1a3bb3d9b5a455d622"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a0c96ce90d2dd2a1a3bb3d9b5a455d622">uart_set_rx_timeout</a> (uart_port_t uart_num, const uint8_t tout_thresh)</td></tr>
<tr class="memdesc:a0c96ce90d2dd2a1a3bb3d9b5a455d622"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART set threshold timeout for TOUT feature.  <a href="#a0c96ce90d2dd2a1a3bb3d9b5a455d622">More...</a><br /></td></tr>
<tr class="separator:a0c96ce90d2dd2a1a3bb3d9b5a455d622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ece9765f327a204dca5924ff5539a2b"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a5ece9765f327a204dca5924ff5539a2b">uart_get_collision_flag</a> (uart_port_t uart_num, bool *collision_flag)</td></tr>
<tr class="memdesc:a5ece9765f327a204dca5924ff5539a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns collision detection flag for RS485 mode Function returns the collision detection flag into variable pointed by collision_flag. *collision_flag = true, if collision detected else it is equal to false. This function should be executed when actual transmission is completed (after <a class="el" href="namespacerb_1_1half__duplex.html#a96caa84729f7fc55f0e5b2837fc9fe3b" title="Send data to the UART port from a given buffer and length,. ">uart_write_bytes()</a>).  <a href="#a5ece9765f327a204dca5924ff5539a2b">More...</a><br /></td></tr>
<tr class="separator:a5ece9765f327a204dca5924ff5539a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac127d35ce7d8746934bf23d62789cfb4"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ac127d35ce7d8746934bf23d62789cfb4">uart_set_wakeup_threshold</a> (uart_port_t uart_num, int wakeup_threshold)</td></tr>
<tr class="memdesc:ac127d35ce7d8746934bf23d62789cfb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of RX pin signal edges for light sleep wakeup.  <a href="#ac127d35ce7d8746934bf23d62789cfb4">More...</a><br /></td></tr>
<tr class="separator:ac127d35ce7d8746934bf23d62789cfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacbdba371beb96c3ac76e5cc92e979a"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#adacbdba371beb96c3ac76e5cc92e979a">uart_get_wakeup_threshold</a> (uart_port_t uart_num, int *out_wakeup_threshold)</td></tr>
<tr class="memdesc:adacbdba371beb96c3ac76e5cc92e979a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of RX pin signal edges for light sleep wakeup.  <a href="#adacbdba371beb96c3ac76e5cc92e979a">More...</a><br /></td></tr>
<tr class="separator:adacbdba371beb96c3ac76e5cc92e979a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688539a27d0ed106ce347b79e83a0f3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a688539a27d0ed106ce347b79e83a0f3a">uart_set_half_duplex_pin</a> (uart_port_t uart_num, gpio_num_t pin)</td></tr>
<tr class="separator:a688539a27d0ed106ce347b79e83a0f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4694d911028546a9444ffad0117a9d7b"><td class="memItemLeft" align="right" valign="top">esp_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a4694d911028546a9444ffad0117a9d7b">uart_wait_tx_done</a> (uart_port_t uart_num, TickType_t ticks_to_wait)</td></tr>
<tr class="memdesc:a4694d911028546a9444ffad0117a9d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until UART TX FIFO is empty.  <a href="#a4694d911028546a9444ffad0117a9d7b">More...</a><br /></td></tr>
<tr class="separator:a4694d911028546a9444ffad0117a9d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96caa84729f7fc55f0e5b2837fc9fe3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a96caa84729f7fc55f0e5b2837fc9fe3b">uart_write_bytes</a> (uart_port_t uart_num, const char *src, size_t size)</td></tr>
<tr class="memdesc:a96caa84729f7fc55f0e5b2837fc9fe3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to the UART port from a given buffer and length,.  <a href="#a96caa84729f7fc55f0e5b2837fc9fe3b">More...</a><br /></td></tr>
<tr class="separator:a96caa84729f7fc55f0e5b2837fc9fe3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cae71bc469939b467af46a5bae8afa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a35cae71bc469939b467af46a5bae8afa">uart_write_bytes_with_break</a> (uart_port_t uart_num, const char *src, size_t size, int brk_len)</td></tr>
<tr class="memdesc:a35cae71bc469939b467af46a5bae8afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to the UART port from a given buffer and length,.  <a href="#a35cae71bc469939b467af46a5bae8afa">More...</a><br /></td></tr>
<tr class="separator:a35cae71bc469939b467af46a5bae8afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aad486903eae2719ad55a0ef2f9994af8"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#aad486903eae2719ad55a0ef2f9994af8">UART_TAG</a> = &quot;uart&quot;</td></tr>
<tr class="separator:aad486903eae2719ad55a0ef2f9994af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75df6ede6007a82332d41a0fd81b2d6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structrb_1_1half__duplex_1_1uart__obj__t.html">uart_obj_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#af75df6ede6007a82332d41a0fd81b2d6">p_uart_obj</a> [UART_NUM_MAX] = {0}</td></tr>
<tr class="separator:af75df6ede6007a82332d41a0fd81b2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e7511b0933aeb278d56d201d523447"><td class="memItemLeft" align="right" valign="top">static DRAM_ATTR uart_dev_t *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a61e7511b0933aeb278d56d201d523447">UART</a> [UART_NUM_MAX] = {&amp;UART0, &amp;UART1, &amp;UART2}</td></tr>
<tr class="separator:a61e7511b0933aeb278d56d201d523447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac883fcf84a8983483aca4be1d9f5dbf4"><td class="memItemLeft" align="right" valign="top">static portMUX_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#ac883fcf84a8983483aca4be1d9f5dbf4">uart_spinlock</a> [UART_NUM_MAX] = {portMUX_INITIALIZER_UNLOCKED, portMUX_INITIALIZER_UNLOCKED, portMUX_INITIALIZER_UNLOCKED}</td></tr>
<tr class="separator:ac883fcf84a8983483aca4be1d9f5dbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abc4fc64bb528b110aca21749f6de6e"><td class="memItemLeft" align="right" valign="top">static portMUX_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerb_1_1half__duplex.html#a3abc4fc64bb528b110aca21749f6de6e">uart_selectlock</a> = portMUX_INITIALIZER_UNLOCKED</td></tr>
<tr class="separator:a3abc4fc64bb528b110aca21749f6de6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a836834577a08951e806331f0616420e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836834577a08951e806331f0616420e9">&#9670;&nbsp;</a></span>uart_check_buf_full()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool rb::half_duplex::uart_check_buf_full </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad54c7f06889b0ed712b2d250957b2b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad54c7f06889b0ed712b2d250957b2b07">&#9670;&nbsp;</a></span>uart_clear_intr_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_clear_intr_status </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clr_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear UART interrupt status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">clr_mask</td><td>Bit mask of the interrupt status to be cleared. The bit mask should be composed from the fields of register UART_INT_CLR_REG.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a85d2011f1b0e3f228f1eb4f4f94da4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d2011f1b0e3f228f1eb4f4f94da4c7">&#9670;&nbsp;</a></span>uart_disable_intr_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_disable_intr_mask </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>disable_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear UART interrupt enable bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">disable_mask</td><td>Bit mask of the disable bits. The bit mask should be composed from the fields of register UART_INT_ENA_REG.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad7e359e6bcc880298e49735dac146104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e359e6bcc880298e49735dac146104">&#9670;&nbsp;</a></span>uart_disable_intr_mask_from_isr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IRAM_ATTR rb::half_duplex::uart_disable_intr_mask_from_isr </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>disable_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ee5d2eaa41053f6a9d08f318c1f7a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee5d2eaa41053f6a9d08f318c1f7a92">&#9670;&nbsp;</a></span>uart_disable_pattern_det_intr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_disable_pattern_det_intr </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART disable pattern detect function. Designed for applications like 'AT commands'. When the hardware detects a series of one same character, the interrupt will be triggered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART port number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aba5ceeafeae68d1ccb30e1edbe24618d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5ceeafeae68d1ccb30e1edbe24618d">&#9670;&nbsp;</a></span>uart_disable_rx_intr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_disable_rx_intr </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable UART RX interrupt (RX_FULL &amp; RX_TIMEOUT INTERRUPT) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2df9353751cbf4ee7b2a037454cbcfb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df9353751cbf4ee7b2a037454cbcfb1">&#9670;&nbsp;</a></span>uart_disable_tx_intr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_disable_tx_intr </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable UART TX interrupt (TX_FULL &amp; TX_TIMEOUT INTERRUPT) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af09968268adff58df7ebc9862d059e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09968268adff58df7ebc9862d059e7d">&#9670;&nbsp;</a></span>uart_driver_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_driver_delete </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uninstall UART driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6397b0ff1a5965aa9e8a798ba4a785c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6397b0ff1a5965aa9e8a798ba4a785c3">&#9670;&nbsp;</a></span>uart_driver_install()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_driver_install </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rx_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tx_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queue_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QueueHandle_t *&#160;</td>
          <td class="paramname"><em>uart_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intr_alloc_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install UART driver. </p>
<p>UART ISR handler will be attached to the same CPU core that this function is running on.</p>
<dl class="section note"><dt>Note</dt><dd>Rx_buffer_size should be greater than UART_FIFO_LEN. Tx_buffer_size should be either zero or greater than UART_FIFO_LEN.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">rx_buffer_size</td><td>UART RX ring buffer size. </td></tr>
    <tr><td class="paramname">tx_buffer_size</td><td>UART TX ring buffer size. If set to zero, driver will not use TX buffer, TX function will block task until all data have been sent out. </td></tr>
    <tr><td class="paramname">queue_size</td><td>UART event queue size/depth. </td></tr>
    <tr><td class="paramname">uart_queue</td><td>UART event queue handle (out param). On success, a new queue handle is written here to provide access to UART events. If set to NULL, driver will not use an event queue. </td></tr>
    <tr><td class="paramname">intr_alloc_flags</td><td>Flags used to allocate the interrupt. One or multiple (ORred) ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info. Do not set ESP_INTR_FLAG_IRAM here (the driver's ISR handler is not located in IRAM)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5732320d43de532f8ee1370c74458ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5732320d43de532f8ee1370c74458ab5">&#9670;&nbsp;</a></span>uart_enable_intr_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_enable_intr_mask </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set UART interrupt enable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">enable_mask</td><td>Bit mask of the enable bits. The bit mask should be composed from the fields of register UART_INT_ENA_REG.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9f769909082c6230487ee9de5e46e946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f769909082c6230487ee9de5e46e946">&#9670;&nbsp;</a></span>uart_enable_intr_mask_from_isr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IRAM_ATTR rb::half_duplex::uart_enable_intr_mask_from_isr </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa970a450c5228ab46ca63c93d190d1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa970a450c5228ab46ca63c93d190d1c9">&#9670;&nbsp;</a></span>uart_enable_pattern_det_intr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_enable_pattern_det_intr </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>pattern_chr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>chr_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>chr_tout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>post_idle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pre_idle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART enable pattern detect function. Designed for applications like 'AT commands'. When the hardware detect a series of one same character, the interrupt will be triggered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART port number. </td></tr>
    <tr><td class="paramname">pattern_chr</td><td>character of the pattern </td></tr>
    <tr><td class="paramname">chr_num</td><td>number of the character, 8bit value. </td></tr>
    <tr><td class="paramname">chr_tout</td><td>timeout of the interval between each pattern characters, 24bit value, unit is APB (80Mhz) clock cycle. When the duration is less than this value, it will not take this data as at_cmd char </td></tr>
    <tr><td class="paramname">post_idle</td><td>idle time after the last pattern character, 24bit value, unit is APB (80Mhz) clock cycle. When the duration is less than this value, it will not take the previous data as the last at_cmd char </td></tr>
    <tr><td class="paramname">pre_idle</td><td>idle time before the first pattern character, 24bit value, unit is APB (80Mhz) clock cycle. When the duration is less than this value, it will not take this data as the first at_cmd char</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a85e6cf79b6bd21c72e3b525c56e4abf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e6cf79b6bd21c72e3b525c56e4abf2">&#9670;&nbsp;</a></span>uart_enable_rx_intr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_enable_rx_intr </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable UART RX interrupt (RX_FULL &amp; RX_TIMEOUT INTERRUPT) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6b3740d2a6ba4eea3ddbc5483c78e9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3740d2a6ba4eea3ddbc5483c78e9d5">&#9670;&nbsp;</a></span>uart_enable_tx_intr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_enable_tx_intr </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable UART TX interrupt (TX_FULL &amp; TX_TIMEOUT INTERRUPT) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">enable</td><td>1: enable; 0: disable </td></tr>
    <tr><td class="paramname">thresh</td><td>Threshold of TX interrupt, 0 ~ UART_FIFO_LEN</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6cdc54423692e437e725175d508ce79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cdc54423692e437e725175d508ce79b">&#9670;&nbsp;</a></span>uart_fill_fifo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rb::half_duplex::uart_fill_fifo </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adfffb16b07365324bf1a80f1f650b0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfffb16b07365324bf1a80f1f650b0f8">&#9670;&nbsp;</a></span>uart_find_pattern_from_last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rb::half_duplex::uart_find_pattern_from_last </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pat_chr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pat_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acae84add2edb2b78454c446f0a3a8599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae84add2edb2b78454c446f0a3a8599">&#9670;&nbsp;</a></span>uart_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_flush </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias of uart_flush_input. UART ring buffer flush. This will discard all data in the UART RX buffer. </p>
<dl class="section note"><dt>Note</dt><dd>Instead of waiting the data sent out, this function will clear UART rx buffer. In order to send all the data in tx FIFO, we can use uart_wait_tx_done function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad29c3d86b7d3fbb00b5853ff29ba1649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29c3d86b7d3fbb00b5853ff29ba1649">&#9670;&nbsp;</a></span>uart_flush_input()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_flush_input </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear input buffer, discard all the data is in the ring-buffer. </p>
<dl class="section note"><dt>Note</dt><dd>In order to send all the data in tx FIFO, we can use uart_wait_tx_done function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7e0a1e454f6c4613d31b401cef8af465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0a1e454f6c4613d31b401cef8af465">&#9670;&nbsp;</a></span>uart_get_baudrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_get_baudrate </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>baudrate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get UART baud rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">baudrate</td><td>Pointer to accept value of UART baud rate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_FAIL Parameter error</li>
<li>ESP_OK Success, result will be put in (*baudrate) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac069f51d37759c69939f5e9a21759dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac069f51d37759c69939f5e9a21759dd5">&#9670;&nbsp;</a></span>uart_get_buffered_data_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_get_buffered_data_len </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART get RX ring buffer cached data length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART port number. </td></tr>
    <tr><td class="paramname">size</td><td>Pointer of size_t to accept cached data length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5ece9765f327a204dca5924ff5539a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ece9765f327a204dca5924ff5539a2b">&#9670;&nbsp;</a></span>uart_get_collision_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_get_collision_flag </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>collision_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns collision detection flag for RS485 mode Function returns the collision detection flag into variable pointed by collision_flag. *collision_flag = true, if collision detected else it is equal to false. This function should be executed when actual transmission is completed (after <a class="el" href="namespacerb_1_1half__duplex.html#a96caa84729f7fc55f0e5b2837fc9fe3b" title="Send data to the UART port from a given buffer and length,. ">uart_write_bytes()</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>Uart number to configure </td></tr>
    <tr><td class="paramname">collision_flag</td><td>Pointer to variable of type bool to return collision flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_ERR_INVALID_ARG Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a143ddb73fd0153c732a02652da75ccb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a143ddb73fd0153c732a02652da75ccb6">&#9670;&nbsp;</a></span>uart_get_hw_flow_ctrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_get_hw_flow_ctrl </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uart_hw_flowcontrol_t *&#160;</td>
          <td class="paramname"><em>flow_ctrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get hardware flow control mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">flow_ctrl</td><td>Option for different flow control mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_FAIL Parameter error</li>
<li>ESP_OK Success, result will be put in (*flow_ctrl) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab4d513be0a9a0d6437e2ad999ba90d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d513be0a9a0d6437e2ad999ba90d67">&#9670;&nbsp;</a></span>uart_get_parity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_get_parity </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uart_parity_t *&#160;</td>
          <td class="paramname"><em>parity_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get UART parity mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">parity_mode</td><td>Pointer to accept value of UART parity mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_FAIL Parameter error</li>
<li>ESP_OK Success, result will be put in (*parity_mode) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac6060066f0f3f6b9846d5bb0389e0ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6060066f0f3f6b9846d5bb0389e0ffb">&#9670;&nbsp;</a></span>uart_get_selectlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">portMUX_TYPE* rb::half_duplex::uart_get_selectlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95ec8dda95f28201f3cf7e13a5b7a804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ec8dda95f28201f3cf7e13a5b7a804">&#9670;&nbsp;</a></span>uart_get_stop_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_get_stop_bits </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uart_stop_bits_t *&#160;</td>
          <td class="paramname"><em>stop_bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get UART stop bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">stop_bits</td><td>Pointer to accept value of UART stop bits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_FAIL Parameter error</li>
<li>ESP_OK Success, result will be put in (*stop_bit) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="adacbdba371beb96c3ac76e5cc92e979a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adacbdba371beb96c3ac76e5cc92e979a">&#9670;&nbsp;</a></span>uart_get_wakeup_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_get_wakeup_threshold </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>out_wakeup_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of RX pin signal edges for light sleep wakeup. </p>
<p>See description of uart_set_wakeup_threshold for the explanation of UART wakeup feature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">uart_num</td><td>UART number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_wakeup_threshold</td><td>output, set to the current value of wakeup threshold for the given UART. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK on success</li>
<li>ESP_ERR_INVALID_ARG if out_wakeup_threshold is NULL </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac11271fb53d8681af2be65b569055b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11271fb53d8681af2be65b569055b6c">&#9670;&nbsp;</a></span>uart_get_word_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_get_word_length </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uart_word_length_t *&#160;</td>
          <td class="paramname"><em>data_bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get UART data bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">data_bit</td><td>Pointer to accept value of UART data bits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_FAIL Parameter error</li>
<li>ESP_OK Success, result will be put in (*data_bit) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad676699d64a0764b4b99ac2c5f81a9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad676699d64a0764b4b99ac2c5f81a9f4">&#9670;&nbsp;</a></span>uart_intr_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_intr_config </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uart_intr_config_t *&#160;</td>
          <td class="paramname"><em>intr_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure UART interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">intr_conf</td><td>UART interrupt settings</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af2a9d9440cef6f37a121e2776bca42fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a9d9440cef6f37a121e2776bca42fb">&#9670;&nbsp;</a></span>uart_isr_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_isr_free </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free UART interrupt handler registered by uart_isr_register. Must be called on the same core as uart_isr_register was called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a27c473d5e0e8583c81a8f5174dfaf6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c473d5e0e8583c81a8f5174dfaf6f0">&#9670;&nbsp;</a></span>uart_isr_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_isr_register </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intr_alloc_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uart_isr_handle_t *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register UART interrupt handler (ISR). </p>
<dl class="section note"><dt>Note</dt><dd>UART ISR handler will be attached to the same CPU core that this function is running on.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">fn</td><td>Interrupt handler function. </td></tr>
    <tr><td class="paramname">arg</td><td>parameter for handler function </td></tr>
    <tr><td class="paramname">intr_alloc_flags</td><td>Flags used to allocate the interrupt. One or multiple (ORred) ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info. </td></tr>
    <tr><td class="paramname">handle</td><td>Pointer to return handle. If non-NULL, a handle for the interrupt will be returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="abcfbcc5c9205f3e44077603f34b12e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcfbcc5c9205f3e44077603f34b12e95">&#9670;&nbsp;</a></span>uart_param_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_param_config </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uart_config_t *&#160;</td>
          <td class="paramname"><em>uart_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set UART configuration parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">uart_config</td><td>UART parameter settings</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5918c60ee771ed97264834ac0e357f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5918c60ee771ed97264834ac0e357f1d">&#9670;&nbsp;</a></span>uart_pattern_dequeue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static esp_err_t rb::half_duplex::uart_pattern_dequeue </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3c5e29896368c1fd8841b880694a4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c5e29896368c1fd8841b880694a4a5">&#9670;&nbsp;</a></span>uart_pattern_enqueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static esp_err_t IRAM_ATTR rb::half_duplex::uart_pattern_enqueue </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3dee405ef18d6f6f8847fd8e7420ea0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dee405ef18d6f6f8847fd8e7420ea0d">&#9670;&nbsp;</a></span>uart_pattern_get_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rb::half_duplex::uart_pattern_get_pos </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the nearest detected pattern position in buffer. The positions of the detected pattern are saved in a queue, This function do nothing to the queue. </p>
<dl class="section note"><dt>Note</dt><dd>If the RX buffer is full and flow control is not enabled, the detected pattern may not be found in the rx buffer due to overflow.</dd></dl>
<p>The following APIs will modify the pattern position info: uart_flush_input, uart_read_bytes, uart_driver_delete, uart_pop_pattern_pos It is the application's responsibility to ensure atomic access to the pattern queue and the rx data buffer when using pattern detect feature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART port number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(-1) No pattern found for current index or parameter error</li>
<li>others the pattern position in rx buffer. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad03d83caf0ba3c404b9e5ce82b1b1e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03d83caf0ba3c404b9e5ce82b1b1e94">&#9670;&nbsp;</a></span>uart_pattern_link_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static esp_err_t rb::half_duplex::uart_pattern_link_free </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f75f37abb2da0ab71a5d75ebea310ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f75f37abb2da0ab71a5d75ebea310ff">&#9670;&nbsp;</a></span>uart_pattern_pop_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rb::half_duplex::uart_pattern_pop_pos </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the nearest detected pattern position in buffer. The positions of the detected pattern are saved in a queue, this function will dequeue the first pattern position and move the pointer to next pattern position. </p>
<dl class="section note"><dt>Note</dt><dd>If the RX buffer is full and flow control is not enabled, the detected pattern may not be found in the rx buffer due to overflow.</dd></dl>
<p>The following APIs will modify the pattern position info: uart_flush_input, uart_read_bytes, uart_driver_delete, uart_pop_pattern_pos It is the application's responsibility to ensure atomic access to the pattern queue and the rx data buffer when using pattern detect feature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART port number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(-1) No pattern found for current index or parameter error</li>
<li>others the pattern position in rx buffer. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac375694c5957acb53a9f2542bac63ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac375694c5957acb53a9f2542bac63ece">&#9670;&nbsp;</a></span>uart_pattern_queue_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_pattern_queue_reset </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queue_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new memory with the given length to save record the detected pattern position in rx buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART port number </td></tr>
    <tr><td class="paramname">queue_length</td><td>Max queue length for the detected pattern. If the queue length is not large enough, some pattern positions might be lost. Set this value to the maximum number of patterns that could be saved in data buffer at the same time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_ERR_NO_MEM No enough memory</li>
<li>ESP_ERR_INVALID_STATE Driver not installed</li>
<li>ESP_FAIL Parameter error</li>
<li>ESP_OK Success </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab44c67ca8076af494ec4ed8a15709b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44c67ca8076af494ec4ed8a15709b26">&#9670;&nbsp;</a></span>uart_pattern_queue_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static esp_err_t rb::half_duplex::uart_pattern_queue_update </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>diff_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acecd33be8298a58b2eede3742a4edab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acecd33be8298a58b2eede3742a4edab1">&#9670;&nbsp;</a></span>uart_read_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rb::half_duplex::uart_read_bytes </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>ticks_to_wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART read bytes from UART buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to the buffer. </td></tr>
    <tr><td class="paramname">length</td><td>data length </td></tr>
    <tr><td class="paramname">ticks_to_wait</td><td>sTimeout, count in RTOS ticks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(-1) Error</li>
<li>OTHERS (&gt;=0) The number of bytes read from UART FIFO </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0dd3bf348fb8ea9292a279ae2a683f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd3bf348fb8ea9292a279ae2a683f40">&#9670;&nbsp;</a></span>uart_reset_rx_fifo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static esp_err_t IRAM_ATTR rb::half_duplex::uart_reset_rx_fifo </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0151a08b86a592f95aa38a3f39d842ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0151a08b86a592f95aa38a3f39d842ad">&#9670;&nbsp;</a></span>uart_rx_intr_handler_default()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IRAM_ATTR rb::half_duplex::uart_rx_intr_handler_default </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a483c207247e1a4fa6eca681a29e241fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a483c207247e1a4fa6eca681a29e241fe">&#9670;&nbsp;</a></span>uart_set_baudrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_set_baudrate </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baudrate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set UART baud rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">baudrate</td><td>UART baud rate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_FAIL Parameter error</li>
<li>ESP_OK Success </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1a4c34c1609324dd8fd9a123e68fa2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4c34c1609324dd8fd9a123e68fa2ed">&#9670;&nbsp;</a></span>uart_set_dtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_set_dtr </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually set the UART DTR pin level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">level</td><td>1: DTR output low; 0: DTR output high</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a688539a27d0ed106ce347b79e83a0f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688539a27d0ed106ce347b79e83a0f3a">&#9670;&nbsp;</a></span>uart_set_half_duplex_pin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rb::half_duplex::uart_set_half_duplex_pin </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpio_num_t&#160;</td>
          <td class="paramname"><em>pin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5936f9c5982e58ca02b756aa94ab085c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5936f9c5982e58ca02b756aa94ab085c">&#9670;&nbsp;</a></span>uart_set_hw_flow_ctrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_set_hw_flow_ctrl </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uart_hw_flowcontrol_t&#160;</td>
          <td class="paramname"><em>flow_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rx_thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set hardware flow control. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">flow_ctrl</td><td>Hardware flow control mode </td></tr>
    <tr><td class="paramname">rx_thresh</td><td>Threshold of Hardware RX flow control (0 ~ UART_FIFO_LEN). Only when UART_HW_FLOWCTRL_RTS is set, will the rx_thresh value be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aabd6856471b26bbcf3d1063277202e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd6856471b26bbcf3d1063277202e1a">&#9670;&nbsp;</a></span>uart_set_line_inverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_set_line_inverse </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>inverse_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set UART line inverse mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">inverse_mask</td><td>Choose the wires that need to be inverted. Inverse_mask should be chosen from UART_INVERSE_RXD / UART_INVERSE_TXD / UART_INVERSE_RTS / UART_INVERSE_CTS, combined with OR operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a51753b8e0db14f66ff7fb88f45cffe82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51753b8e0db14f66ff7fb88f45cffe82">&#9670;&nbsp;</a></span>uart_set_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_set_mode </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uart_mode_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART set communication mode. </p>
<dl class="section note"><dt>Note</dt><dd>This function must be executed after <a class="el" href="namespacerb_1_1half__duplex.html#a6397b0ff1a5965aa9e8a798ba4a785c3" title="Install UART driver. ">uart_driver_install()</a>, when the driver object is initialized. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>Uart number to configure </td></tr>
    <tr><td class="paramname">mode</td><td>UART UART mode to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_ERR_INVALID_ARG Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="acc501d08d388094fc40ed62e68f6b214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc501d08d388094fc40ed62e68f6b214">&#9670;&nbsp;</a></span>uart_set_parity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_set_parity </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uart_parity_t&#160;</td>
          <td class="paramname"><em>parity_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set UART parity mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">parity_mode</td><td>the enum of uart parity configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_FAIL Parameter error</li>
<li>ESP_OK Success </li>
</ul>
</dd></dl>

</div>
</div>
<a id="adb5d171e9b2736dbe54067b292bac9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb5d171e9b2736dbe54067b292bac9dc">&#9670;&nbsp;</a></span>uart_set_pin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_set_pin </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tx_io_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rx_io_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rts_io_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cts_io_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set UART pin number. </p>
<dl class="section note"><dt>Note</dt><dd>Internal signal can be output to multiple GPIO pads. Only one GPIO pad can connect with input signal.</dd>
<dd>
Instead of GPIO number a macro 'UART_PIN_NO_CHANGE' may be provided to keep the currently allocated pin.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">tx_io_num</td><td>UART TX pin GPIO number. </td></tr>
    <tr><td class="paramname">rx_io_num</td><td>UART RX pin GPIO number. </td></tr>
    <tr><td class="paramname">rts_io_num</td><td>UART RTS pin GPIO number. </td></tr>
    <tr><td class="paramname">cts_io_num</td><td>UART CTS pin GPIO number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac9c9b3532a4f3c6e82fb9e0db54bd2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c9b3532a4f3c6e82fb9e0db54bd2b1">&#9670;&nbsp;</a></span>uart_set_rts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_set_rts </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually set the UART RTS pin level. </p>
<dl class="section note"><dt>Note</dt><dd>UART must be configured with hardware flow control disabled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">level</td><td>1: RTS output low (active); 0: RTS output high (block)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0c96ce90d2dd2a1a3bb3d9b5a455d622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c96ce90d2dd2a1a3bb3d9b5a455d622">&#9670;&nbsp;</a></span>uart_set_rx_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_set_rx_timeout </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tout_thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART set threshold timeout for TOUT feature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>Uart number to configure </td></tr>
    <tr><td class="paramname">tout_thresh</td><td>This parameter defines timeout threshold in uart symbol periods. The maximum value of threshold is 126. tout_thresh = 1, defines TOUT interrupt timeout equal to transmission time of one symbol (~11 bit) on current baudrate. If the time is expired the UART_RXFIFO_TOUT_INT interrupt is triggered. If tout_thresh == 0, the TOUT feature is disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_ERR_INVALID_ARG Parameter error</li>
<li>ESP_ERR_INVALID_STATE Driver is not installed </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a02508deed3506a2f99cbc6cb502d5181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02508deed3506a2f99cbc6cb502d5181">&#9670;&nbsp;</a></span>uart_set_select_notif_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rb::half_duplex::uart_set_select_notif_callback </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uart_select_notif_callback_t&#160;</td>
          <td class="paramname"><em>uart_select_notif_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18a324f4c4610022fc6632f89b90f6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a324f4c4610022fc6632f89b90f6ca">&#9670;&nbsp;</a></span>uart_set_stop_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_set_stop_bits </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uart_stop_bits_t&#160;</td>
          <td class="paramname"><em>stop_bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set UART stop bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">stop_bits</td><td>UART stop bits</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Fail </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aca401845d54986ace8201c3944d38ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca401845d54986ace8201c3944d38ce1">&#9670;&nbsp;</a></span>uart_set_sw_flow_ctrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_set_sw_flow_ctrl </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rx_thresh_xon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rx_thresh_xoff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set software flow control. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">enable</td><td>switch on or off </td></tr>
    <tr><td class="paramname">rx_thresh_xon</td><td>low water mark </td></tr>
    <tr><td class="paramname">rx_thresh_xoff</td><td>high water mark</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a005ad69a3593c666192633b064a863ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005ad69a3593c666192633b064a863ce">&#9670;&nbsp;</a></span>uart_set_tx_idle_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_set_tx_idle_num </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>idle_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set UART idle interval after tx FIFO is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">idle_num</td><td>idle interval after tx FIFO is empty(unit: the time it takes to send one bit under current baudrate)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac127d35ce7d8746934bf23d62789cfb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac127d35ce7d8746934bf23d62789cfb4">&#9670;&nbsp;</a></span>uart_set_wakeup_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_set_wakeup_threshold </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wakeup_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of RX pin signal edges for light sleep wakeup. </p>
<p>UART can be used to wake up the system from light sleep. This feature works by counting the number of positive edges on RX pin and comparing the count to the threshold. When the count exceeds the threshold, system is woken up from light sleep. This function allows setting the threshold value.</p>
<p>Stop bit and parity bits (if enabled) also contribute to the number of edges. For example, letter 'a' with ASCII code 97 is encoded as 0100001101 on the wire (with 8n1 configuration), start and stop bits included. This sequence has 3 positive edges (transitions from 0 to 1). Therefore, to wake up the system when 'a' is sent, set wakeup_threshold=3.</p>
<p>The character that triggers wakeup is not received by UART (i.e. it can not be obtained from UART FIFO). Depending on the baud rate, a few characters after that will also not be received. Note that when the chip enters and exits light sleep mode, APB frequency will be changing. To make sure that UART has correct baud rate all the time, select REF_TICK as UART clock source, by setting use_ref_tick field in uart_config_t to true.</p>
<dl class="section note"><dt>Note</dt><dd>in ESP32, the wakeup signal can only be input via IO_MUX (i.e. GPIO3 should be configured as function_1 to wake up UART0, GPIO9 should be configured as function_5 to wake up UART1), UART2 does not support light sleep wakeup feature.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART number </td></tr>
    <tr><td class="paramname">wakeup_threshold</td><td>number of RX edges for light sleep wakeup, value is 3 .. 0x3ff. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK on success</li>
<li>ESP_ERR_INVALID_ARG if uart_num is incorrect or wakeup_threshold is outside of [3, 0x3ff] range. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a27d66366ac4fdbde6a6beebe94e2233b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d66366ac4fdbde6a6beebe94e2233b">&#9670;&nbsp;</a></span>uart_set_word_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_set_word_length </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uart_word_length_t&#160;</td>
          <td class="paramname"><em>data_bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set UART data bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">data_bit</td><td>UART data bits</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2e2a4b68f4c6d055da05d9be37b85de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2a4b68f4c6d055da05d9be37b85de4">&#9670;&nbsp;</a></span>uart_tx_chars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rb::half_duplex::uart_tx_chars </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data to the UART port from a given buffer and length. </p>
<p>This function will not wait for enough space in TX FIFO. It will just fill the available TX FIFO and return when the FIFO is full. </p><dl class="section note"><dt>Note</dt><dd>This function should only be used when UART TX buffer is not enabled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">buffer</td><td>data buffer address </td></tr>
    <tr><td class="paramname">len</td><td>data length to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(-1) Parameter error</li>
<li>OTHERS (&gt;=0) The number of bytes pushed to the TX FIFO </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4694d911028546a9444ffad0117a9d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4694d911028546a9444ffad0117a9d7b">&#9670;&nbsp;</a></span>uart_wait_tx_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">esp_err_t rb::half_duplex::uart_wait_tx_done </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>ticks_to_wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until UART TX FIFO is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">ticks_to_wait</td><td>Timeout, count in RTOS ticks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>ESP_OK Success</li>
<li>ESP_FAIL Parameter error</li>
<li>ESP_ERR_TIMEOUT Timeout </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a96caa84729f7fc55f0e5b2837fc9fe3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96caa84729f7fc55f0e5b2837fc9fe3b">&#9670;&nbsp;</a></span>uart_write_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rb::half_duplex::uart_write_bytes </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data to the UART port from a given buffer and length,. </p>
<p>If the UART driver's parameter 'tx_buffer_size' is set to zero: This function will not return until all the data have been sent out, or at least pushed into TX FIFO.</p>
<p>Otherwise, if the 'tx_buffer_size' &gt; 0, this function will return after copying all the data to tx ring buffer, UART ISR will then move data from the ring buffer to TX FIFO gradually.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">src</td><td>data buffer address </td></tr>
    <tr><td class="paramname">size</td><td>data length to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(-1) Parameter error</li>
<li>OTHERS (&gt;=0) The number of bytes pushed to the TX FIFO </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a35cae71bc469939b467af46a5bae8afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35cae71bc469939b467af46a5bae8afa">&#9670;&nbsp;</a></span>uart_write_bytes_with_break()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rb::half_duplex::uart_write_bytes_with_break </td>
          <td>(</td>
          <td class="paramtype">uart_port_t&#160;</td>
          <td class="paramname"><em>uart_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>brk_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data to the UART port from a given buffer and length,. </p>
<p>If the UART driver's parameter 'tx_buffer_size' is set to zero: This function will not return until all the data and the break signal have been sent out. After all data is sent out, send a break signal.</p>
<p>Otherwise, if the 'tx_buffer_size' &gt; 0, this function will return after copying all the data to tx ring buffer, UART ISR will then move data from the ring buffer to TX FIFO gradually. After all data sent out, send a break signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_num</td><td>UART_NUM_0, UART_NUM_1 or UART_NUM_2 </td></tr>
    <tr><td class="paramname">src</td><td>data buffer address </td></tr>
    <tr><td class="paramname">size</td><td>data length to send </td></tr>
    <tr><td class="paramname">brk_len</td><td>break signal duration(unit: the time it takes to send one bit at current baudrate)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(-1) Parameter error</li>
<li>OTHERS (&gt;=0) The number of bytes pushed to the TX FIFO </li>
</ul>
</dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="af75df6ede6007a82332d41a0fd81b2d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75df6ede6007a82332d41a0fd81b2d6">&#9670;&nbsp;</a></span>p_uart_obj</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrb_1_1half__duplex_1_1uart__obj__t.html">uart_obj_t</a>* rb::half_duplex::p_uart_obj[UART_NUM_MAX] = {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a61e7511b0933aeb278d56d201d523447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e7511b0933aeb278d56d201d523447">&#9670;&nbsp;</a></span>UART</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DRAM_ATTR uart_dev_t* const rb::half_duplex::UART[UART_NUM_MAX] = {&amp;UART0, &amp;UART1, &amp;UART2}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3abc4fc64bb528b110aca21749f6de6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3abc4fc64bb528b110aca21749f6de6e">&#9670;&nbsp;</a></span>uart_selectlock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">portMUX_TYPE rb::half_duplex::uart_selectlock = portMUX_INITIALIZER_UNLOCKED</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac883fcf84a8983483aca4be1d9f5dbf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac883fcf84a8983483aca4be1d9f5dbf4">&#9670;&nbsp;</a></span>uart_spinlock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">portMUX_TYPE rb::half_duplex::uart_spinlock[UART_NUM_MAX] = {portMUX_INITIALIZER_UNLOCKED, portMUX_INITIALIZER_UNLOCKED, portMUX_INITIALIZER_UNLOCKED}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad486903eae2719ad55a0ef2f9994af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad486903eae2719ad55a0ef2f9994af8">&#9670;&nbsp;</a></span>UART_TAG</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* rb::half_duplex::UART_TAG = &quot;uart&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Feb 6 2021 13:10:00 for RBControl by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
